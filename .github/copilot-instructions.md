[//]: # (## tutorial/index.md)

[//]: # ()
[//]: # (--- title: Tutorial ---)

[//]: # ()
[//]: # (## tutorial/01-svelte/index.md)

[//]: # ()
[//]: # (--- title: Basic Svelte label: Part 1 scope: { 'prefix': '/src/lib/', 'name': 'src' } focus: /src/lib/App.svelte ---)

[//]: # ()
[//]: # (## tutorial/01-svelte/01-introduction/index.md)

[//]: # ()
[//]: # (--- title: Introduction scope: { 'prefix': '/src/lib/', 'name': 'src' } focus: /src/lib/App.svelte ---)

[//]: # ()
[//]: # (## tutorial/01-svelte/01-introduction/01-welcome-to-svelte/index.md)

[//]: # ()
[//]: # (--- title: Welcome to Svelte --- Welcome to the Svelte tutorial! This will teach you everything you need to know to easily build web applications of all sizes, with high performance and a small footprint. You can also consult the [API docs]&#40;/docs&#41; and visit the [playground]&#40;/playground&#41;, or — if you're impatient to start hacking on your machine locally — create a project with `npx sv create`. ## What is Svelte? Svelte is a tool for building web applications. Like other user interface frameworks, it allows you to build your app _declaratively_ out of components that combine markup, styles and behaviours. These components are _compiled_ into small, efficient JavaScript modules that eliminate overhead traditionally associated with UI frameworks. You can build your entire app with Svelte &#40;for example, using an application framework like [SvelteKit]&#40;/docs/kit&#41;, which this tutorial will cover&#41;, or you can add it incrementally to an existing codebase. You can also ship components as standalone packages that work anywhere. ## How to use this tutorial This tutorial is split into four main parts: - [Basic Svelte]&#40;/tutorial/svelte/welcome-to-svelte&#41; &#40;you are here&#41; - [Advanced Svelte]&#40;/tutorial/svelte/tweens&#41; - [Basic SvelteKit]&#40;/tutorial/kit/introducing-sveltekit&#41; - [Advanced SvelteKit]&#40;/tutorial/kit/optional-params&#41; Each section will present an exercise designed to illustrate a feature. Later exercises build on the knowledge gained in earlier ones, so it's recommended that you go from start to finish. If necessary, you can navigate via the menu above. If you get stuck, you can click the `solve` button in the top right of the screen. &#40;The `solve` button is disabled on sections like this one that don't include an exercise.&#41; Try not to rely on it too much; you will learn faster by figuring out where to put each suggested code block and manually typing it in to the editor.)

[//]: # ()
[//]: # (## tutorial/01-svelte/01-introduction/02-your-first-component/index.md)

[//]: # ()
[//]: # (--- title: Your first component --- In Svelte, an application is composed from one or more _components_. A component is a reusable self-contained block of code that encapsulates HTML, CSS and JavaScript that belong together, written into a `.svelte` file. The `App.svelte` file, open in the code editor to the right, is a simple component. ## Adding data A component that just renders some static markup isn't very interesting. Let's add some data. First, add a script tag to your component and declare a `name` variable: `svelte /// file: App.svelte <script> let name = 'Svelte'; </script> <h1>Hello world!</h1> ` Then, we can refer to `name` in the markup: `svelte /// file: App.svelte <h1>Hello{name}!</h1> ` Inside the curly braces, we can put any JavaScript we want. Try changing `name` to `name.toUpperCase&#40;&#41;` for a shoutier greeting. `svelte /// file: App.svelte <h1>Hello {name.toUpperCase&#40;&#41;}!</h1> `)

[//]: # ()
[//]: # (## tutorial/01-svelte/01-introduction/03-dynamic-attributes/index.md)

[//]: # ()
[//]: # (--- title: Dynamic attributes --- Just like you can use curly braces to control text, you can use them to control element attributes. Our image is missing a `src` — let's add one: `svelte /// file: App.svelte <imgsrc={src}/> ` That's better. But if you hover over the `<img>` in the editor, Svelte is giving us a warning: `` `<img>` element should have an alt attribute `` When building web apps, it's important to make sure that they're _accessible_ to the broadest possible userbase, including people with &#40;for example&#41; impaired vision or motion, or people without powerful hardware or good internet connections. Accessibility &#40;shortened to a11y&#41; isn't always easy to get right, but Svelte will help by warning you if you write inaccessible markup. In this case, we're missing the `alt` attribute that describes the image for people using screenreaders, or people with slow or flaky internet connections that can't download the image. Let's add one: `svelte /// file: App.svelte <img src={src}alt="A man dances."/> ` We can use curly braces _inside_ attributes. Try changing it to `"{name} dances."` — remember to declare a `name` variable in the `<script>` block. ## Shorthand attributes It's not uncommon to have an attribute where the name and value are the same, like `src={src}`. Svelte gives us a convenient shorthand for these cases: `svelte /// file: App.svelte <img{src}alt="{name} dances." /> `)

[//]: # ()
[//]: # (## tutorial/01-svelte/01-introduction/04-styling/index.md)

[//]: # ()
[//]: # (--- title: Styling --- Just like in HTML, you can add a `<style>` tag to your component. Let's add some styles to the `<p>` element: `svelte /// file: App.svelte <p>This is a paragraph.</p> <style> p { color: goldenrod; font-family: 'Comic Sans MS', cursive; font-size: 2em; } </style> ` Importantly, these rules are _scoped to the component_. You won't accidentally change the style of `<p>` elements elsewhere in your app, as we'll see in the next step.)

[//]: # ()
[//]: # (## tutorial/01-svelte/01-introduction/05-nested-components/index.md)

[//]: # ()
[//]: # (--- title: Nested components --- It would be impractical to put your entire app in a single component. Instead, we can import components from other files and include them in our markup. Add a `<script>` tag to the top of `App.svelte` that imports `Nested.svelte`... `svelte /// file: App.svelte <script> import Nested from './Nested.svelte'; </script> ` ...and include a `<Nested />` component: `svelte /// file: App.svelte <p>This is a paragraph.</p> <Nested /> ` Notice that even though `Nested.svelte` has a `<p>` element, the styles from `App.svelte` don't leak in.)

[//]: # ()
[//]: # (## tutorial/01-svelte/01-introduction/06-html-tags/index.md)

[//]: # ()
[//]: # (--- title: HTML tags --- Ordinarily, strings are inserted as plain text, meaning that characters like `<` and `>` have no special meaning. But sometimes you need to render HTML directly into a component. For example, the words you're reading right now exist in a markdown file that gets included on this page as a blob of HTML. In Svelte, you do this with the special `{@html ...}` tag: `svelte /// file: App.svelte <p>{@htmlstring}</p> `)

[//]: # ()
[//]: # (## tutorial/01-svelte/02-reactivity/index.md)

[//]: # ()
[//]: # (--- title: Reactivity scope: { 'prefix': '/src/lib/', 'name': 'src' } focus: /src/lib/App.svelte ---)

[//]: # ()
[//]: # (## tutorial/01-svelte/02-reactivity/01-state/index.md)

[//]: # ()
[//]: # (--- title: State --- At the heart of Svelte is a powerful system of _reactivity_ for keeping the DOM in sync with your application state — for example, in response to an event. Make the `count` declaration reactive by wrapping the value with `$state&#40;...&#41;`: `js /// file: App.svelte let count =$state&#40;0&#41;; ` This is called a _rune_, and it's how you tell Svelte that `count` isn't an ordinary variable. Runes look like functions, but they're not — when you use Svelte, they're part of the language itself. All that's left is to implement `increment`: `js /// file: App.svelte function increment&#40;&#41; { count += 1; } `)

[//]: # ()
[//]: # (## tutorial/01-svelte/02-reactivity/02-deep-state/index.md)

[//]: # ()
[//]: # (--- title: Deep state --- As we saw in the previous exercise, state reacts to _reassignments_. But it also reacts to _mutations_ — we call this _deep reactivity_. Make `numbers` a reactive array: `js /// file: App.svelte let numbers =$state&#40;[1, 2, 3, 4]&#41;; ` Now, when we change the array... `js /// file: App.svelte function addNumber&#40;&#41; { numbers[numbers.length] = numbers.length + 1; } ` ...the component updates. Or better still, we can `push` to the array instead: `js /// file: App.svelte function addNumber&#40;&#41; { numbers.push&#40;numbers.length + 1&#41;; } `)

[//]: # ()
[//]: # (## tutorial/01-svelte/02-reactivity/03-derived-state/index.md)

[//]: # ()
[//]: # (--- title: Derived state --- Often, you will need to _derive_ state from other state. For this, we have the `$derived` rune: `js /// file: App.svelte let numbers = $state&#40;[1, 2, 3, 4]&#41;; let total = $derived&#40;numbers.reduce&#40;&#40;t, n&#41; => t + n, 0&#41;&#41;; ` We can now use this in our markup: `svelte /// file: App.svelte <p>{numbers.join&#40;' + '&#41;} ={total}</p> ` The expression inside the `$derived` declaration will be re-evaluated whenever its dependencies &#40;in this case, just `numbers`&#41; are updated. Unlike normal state, derived state is read-only.)

[//]: # ()
[//]: # (## tutorial/01-svelte/02-reactivity/04-inspecting-state/index.md)

[//]: # ()
[//]: # (--- title: Inspecting state --- It's often useful to be able to track the value of a piece of state as it changes over time. Inside the `addNumber` function, we've added a `console.log` statement. But if you click the button and open the console drawer &#40;using the button to the right of the URL bar&#41;, you'll see a warning, and a message saying the message could not be cloned. That's because `numbers` is a reactive [proxy]&#40;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy&#41;. There are a couple of things we can do. Firstly, we can create a non-reactive _snapshot_ of the state with `$state.snapshot&#40;...&#41;`: `js /// file: App.svelte function addNumber&#40;&#41; { numbers.push&#40;numbers.length + 1&#41;; console.log&#40;$state.snapshot&#40;numbers&#41;&#41;; } ` Alternatively, we can use the `$inspect` rune to automatically log a snapshot of the state whenever it changes. This code will automatically be stripped out of your production build: `js /// file: App.svelte function addNumber&#40;&#41; { numbers.push&#40;numbers.length + 1&#41;; console.log&#40;$state.snapshot&#40;numbers&#41;&#41;; } $inspect&#40;numbers&#41;; ` You can customise how the information is displayed by using `$inspect&#40;...&#41;.with&#40;fn&#41;` — for example, you can use `console.trace` to see where the state change originated from: `js /// file: App.svelte $inspect&#40;numbers&#41;.with&#40;console.trace&#41;; `)

[//]: # ()
[//]: # (## tutorial/01-svelte/02-reactivity/05-effects/index.md)

[//]: # ()
[//]: # (--- title: Effects --- So far we've talked about reactivity in terms of state. But that's only half of the equation — state is only reactive if something is _reacting_ to it, otherwise it's just a sparkling variable. The thing that reacts is called an _effect_. You've already encountered effects — the ones that Svelte creates on your behalf to update the DOM in response to state changes — but you can also create your own with the `$effect` rune. Let's say we want to use `setInterval` to keep track of how long the component has been mounted. Create the effect: `svelte /// file: App.svelte <script> let elapsed = $state&#40;0&#41;; let interval = $state&#40;1000&#41;; $effect&#40;&#40;&#41; => { setInterval&#40;&#40;&#41; => { elapsed += 1; }, interval&#41;; }&#41;; </script> ` Click the 'speed up' button a few times and notice that `elapsed` ticks up faster, because we're calling `setInterval` each time `interval` gets smaller. If we then click the 'slow down' button... well, it doesn't work. That's because we're not clearing out the old intervals when the effect updates. We can fix that by returning a cleanup function: `js /// file: App.svelte $effect&#40;&#40;&#41; => { const id =setInterval&#40;&#40;&#41; => { elapsed += 1; }, interval&#41;; return &#40;&#41; => { clearInterval&#40;id&#41;; }; }&#41;; ` The cleanup function is called immediately before the effect function re-runs when `interval` changes, and also when the component is destroyed. If the effect function doesn't read any state when it runs, it will only run once, when the component mounts.)

[//]: # ()
[//]: # (## tutorial/01-svelte/02-reactivity/06-universal-reactivity/index.md)

[//]: # ()
[//]: # (--- title: Universal reactivity --- In the preceding exercises, we used runes to add reactivity inside components. But we can also use runes _outside_ components, for example to share some global state. The `<Counter>` components in this exercise are all importing the `counter` object from `shared.js`. But it's a normal object, and as such nothing happens when you click the buttons. Wrap the object in `$state&#40;...&#41;`: `js /// file: shared.js export const counter =$state&#40;{ count: 0 }&#41;; ` This causes an error, because you can't use runes in normal `.js` files, only `.svelte.js` files. Let's fix that — rename the file to `shared.svelte.js`. Then, update the import declaration in `Counter.svelte`: `svelte /// file: Counter.svelte <script> import { counter } from './shared.svelte.js'; </script> ` Now, when you click any button, all three update simultaneously.)

[//]: # ()
[//]: # (## tutorial/01-svelte/03-props/index.md)

[//]: # ()
[//]: # (--- title: Props scope: { 'prefix': '/src/lib/', 'name': 'src' } focus: /src/lib/App.svelte ---)

[//]: # ()
[//]: # (## tutorial/01-svelte/03-props/01-declaring-props/index.md)

[//]: # ()
[//]: # (--- title: Declaring props --- So far, we've dealt exclusively with internal state — that is to say, the values are only accessible within a given component. In any real application, you'll need to pass data from one component down to its children. To do that, we need to declare _properties_, generally shortened to 'props'. In Svelte, we do that with the `$props` rune. Edit the `Nested.svelte` component: `svelte /// file: Nested.svelte <script> let { answer } =$props&#40;&#41;; </script> `)

[//]: # ()
[//]: # (## tutorial/01-svelte/03-props/02-default-values/index.md)

[//]: # ()
[//]: # (--- title: Default values --- We can easily specify default values for props in `Nested.svelte`: `svelte /// file: Nested.svelte <script> let { answer= 'a mystery'} = $props&#40;&#41;; </script> ` If we now add a second component _without_ an `answer` prop, it will fall back to the default: `svelte /// file: App.svelte <Nested answer={42}/> <Nested /> `)

[//]: # ()
[//]: # (## tutorial/01-svelte/03-props/03-spread-props/index.md)

[//]: # ()
[//]: # (--- title: Spread props --- In this exercise, in `App.svelte` we've forgotten to pass the `name` prop expected by `PackageInfo.svelte`, meaning the `<code>` element is empty and the npm link is broken. We _could_ fix it by adding the prop... `svelte /// file: App.svelte <PackageInfo name={pkg.name} version={pkg.version} description={pkg.description} website={pkg.website} /> ` ...but since the properties of `pkg` correspond to the component's expected props, we can 'spread' them onto the component instead: `svelte /// file: App.svelte <PackageInfo{...pkg}/> ` > > `js > let { name, ...stuff } = $props&#40;&#41;; > ` > > ...or by skipping [destructuring]&#40;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&#41; altogether: > > `js > let stuff = $props&#40;&#41;; > ` > > ...in which case you can access the properties by their object paths: > > `js > console.log&#40;stuff.name, stuff.version, stuff.description, stuff.website&#41;; > `)

[//]: # ()
[//]: # (## tutorial/01-svelte/04-logic/index.md)

[//]: # ()
[//]: # (--- title: Logic scope: { 'prefix': '/src/lib/', 'name': 'src' } focus: /src/lib/App.svelte ---)

[//]: # ()
[//]: # (## tutorial/01-svelte/04-logic/01-if-blocks/index.md)

[//]: # ()
[//]: # (--- title: If blocks --- HTML doesn't have a way of expressing _logic_, like conditionals and loops. Svelte does. To conditionally render some markup, we wrap it in an `if` block. Let's add some text that appears when `count` is greater than `10`: `svelte /// file: App.svelte <button onclick={increment}> Clicked {count} {count === 1 ? 'time' : 'times'} </button> {#if count > 10} <p>{count} is greater than 10</p> {/if} ` Try it — update the component, and click on the button a few times.)

[//]: # ()
[//]: # (## tutorial/01-svelte/04-logic/02-else-blocks/index.md)

[//]: # ()
[//]: # (--- title: Else blocks --- Just like in JavaScript, an `if` block can have an `else` block: `svelte /// file: App.svelte {#if count > 10} <p>{count} is greater than 10</p> {:else} <p>{count} is between 0 and 10</p> {/if} ` `{#...}` opens a block. `{/...}` closes a block. `{:...}` _continues_ a block. Congratulations — you've already learned almost all the syntax Svelte adds to HTML.)

[//]: # ()
[//]: # (## tutorial/01-svelte/04-logic/03-else-if-blocks/index.md)

[//]: # ()
[//]: # (--- title: Else-if blocks --- Multiple conditions can be 'chained' together with `else if`: `svelte /// file: App.svelte {#if count > 10} <p>{count} is greater than 10</p> {:else if count < 5} <p>{count} is less than 5</p> {:else} <p>{count} is between5and 10</p> {/if} `)

[//]: # ()
[//]: # (## tutorial/01-svelte/04-logic/04-each-blocks/index.md)

[//]: # ()
[//]: # (--- title: Each blocks --- When building user interfaces you'll often find yourself working with lists of data. In this exercise, we've repeated the `<button>` markup multiple times — changing the colour each time — but there's still more to add. Instead of laboriously copying, pasting and editing, we can get rid of all but the first button, then use an `each` block: `svelte /// file: App.svelte <div> {#each colors as color} <button style="background: red" aria-label="red" aria-current={selected === 'red'} onclick={&#40;&#41; => selected = 'red'} ></button> {/each} </div> ` Now we need to use the `color` variable in place of `"red"`: `svelte /// file: App.svelte <div> {#each colors as color} <button style="background:{color}" aria-label={color} aria-current={selected ===color} onclick={&#40;&#41; => selected =color} ></button> {/each} </div> ` You can get the current _index_ as a second argument, like so: `svelte /// file: App.svelte <div> {#each colors as color,i} <button style="background: {color}" aria-label={color} aria-current={selected === color} onclick={&#40;&#41; => selected = color} >{i + 1}</button> {/each} </div> `)

[//]: # ()
[//]: # (## tutorial/01-svelte/04-logic/05-keyed-each-blocks/index.md)

[//]: # ()
[//]: # (--- title: Keyed each blocks --- By default, updating the value of an `each` block will add or remove DOM nodes at the _end_ of the block if the size changes, and update the remaining DOM. That might not be what you want. It's easier to show why than to explain. Inside `Thing.svelte`, `name` is a dynamic prop but `emoji` is a constant. Click the 'Remove first thing' button a few times, and notice what happens: 1. It removes the last component. 2. It then updates the `name` value in the remaining DOM nodes &#40;the text node containing 'doughnut' now contains 'egg', and so on&#41;, but not the emoji. One way to fix it would be to make `emoji` a [`$derived`]&#40;derived-state&#41; value. But it makes more sense to remove the first `<Thing>` component altogether rather than remove the _last_ one and update all the others. To do that, we specify a unique _key_ for each iteration of the `each` block: `svelte /// file: App.svelte {#each things as thing &#40;thing.id&#41;} <Thing name={thing.name}/> {/each} `)

[//]: # ()
[//]: # (## tutorial/01-svelte/04-logic/06-await-blocks/index.md)

[//]: # ()
[//]: # (--- title: Await blocks --- Most web applications have to deal with asynchronous data at some point. Svelte makes it easy to _await_ the value of [promises]&#40;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises&#41; directly in your markup: `svelte /// file: App.svelte {#await promise} <p>...rolling</p> {:then number} <p>you rolled a {number}!</p> {:catch error} <p style="color: red">{error.message}</p> {/await} ` If you know that your promise can't reject, you can omit the `catch` block. You can also omit the first block if you don't want to show anything until the promise resolves: `svelte {#await promise then number} <p>you rolled a {number}!</p> {/await} `)

[//]: # ()
[//]: # (## tutorial/01-svelte/05-events/index.md)

[//]: # ()
[//]: # (--- title: Events scope: { 'prefix': '/src/lib/', 'name': 'src' } focus: /src/lib/App.svelte ---)

[//]: # ()
[//]: # (## tutorial/01-svelte/05-events/01-dom-events/index.md)

[//]: # ()
[//]: # (--- title: DOM events --- As we've briefly seen already, you can listen to any DOM event on an element &#40;such as click or [pointermove]&#40;https://developer.mozilla.org/en-US/docs/Web/API/Element/pointermove_event&#41;&#41; with an `on<name>` function: `svelte /// file: App.svelte <divonpointermove={onpointermove}> The pointer is at {Math.round&#40;m.x&#41;} x {Math.round&#40;m.y&#41;} </div> ` Like with any other property where the name matches the value, we can use the short form: `svelte /// file: App.svelte <div{onpointermove}> The pointer is at {Math.round&#40;m.x&#41;} x {Math.round&#40;m.y&#41;} </div> `)

[//]: # ()
[//]: # (## tutorial/01-svelte/05-events/02-inline-handlers/index.md)

[//]: # ()
[//]: # (--- title: Inline handlers --- You can also declare event handlers inline: `svelte /// file: App.svelte <script> let m = $state&#40;{ x: 0, y: 0 }&#41;; function onpointermove&#40;event&#41; { m.x = event.clientX; m.y = event.clientY; } </script> <div onpointermove={&#40;event&#41; => { m.x = event.clientX; m.y = event.clientY; }} > The pointer is at {m.x} x {m.y} </div> `)

[//]: # ()
[//]: # (## tutorial/01-svelte/05-events/03-capturing/index.md)

[//]: # ()
[//]: # (--- title: Capturing --- Normally, event handlers run during the [_bubbling_]&#40;https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Event_bubbling&#41; phase. Notice what happens if you type something into the `<input>` in this example — the inner handler runs first, as the event 'bubbles' from the target up to the document, followed by the outer handler. Sometimes, you want handlers to run during the _capture_ phase instead. Add `capture` to the end of the event name: ``svelte /// file: App.svelte <div onkeydowncapture={&#40;e&#41; => alert&#40;`<div> ${e.key}`&#41;} role="presentation"> <input onkeydowncapture={&#40;e&#41; => alert&#40;`<input> ${e.key}`&#41;} /> </div> `` Now, the relative order is reversed. If both capturing and non-capturing handlers exist for a given event, the capturing handlers will run first.)

[//]: # ()
[//]: # (## tutorial/01-svelte/05-events/04-component-events/index.md)

[//]: # ()
[//]: # (--- title: Component events --- You can pass event handlers to components like any other prop. In `Stepper.svelte`, add `increment` and `decrement` props... `svelte /// file: Stepper.svelte <script> let{ increment, decrement }= $props&#40;&#41;; </script> ` ...and wire them up: `svelte /// file: Stepper.svelte <buttononclick={decrement}>-1</button> <buttononclick={increment}>+1</button> ` In `App.svelte`, define the handlers: `svelte /// file: App.svelte <Stepper increment={&#40;&#41; => value += 1} decrement={&#40;&#41; => value -= 1} /> `)

[//]: # ()
[//]: # (## tutorial/01-svelte/05-events/05-spreading-events/index.md)

[//]: # ()
[//]: # (--- title: Spreading events --- We can also [spread]&#40;spread-props&#41; event handlers directly onto elements. Here, we've defined an `onclick` handler in `App.svelte` — all we need to do is pass the props to the `<button>` in `BigRedButton.svelte`: `svelte /// file: BigRedButton.svelte <button{...props}> Push </button> `)

[//]: # ()
[//]: # (## tutorial/01-svelte/06-bindings/index.md)

[//]: # ()
[//]: # (--- title: Bindings scope: { 'prefix': '/src/lib/', 'name': 'src' } focus: /src/lib/App.svelte ---)

[//]: # ()
[//]: # (## tutorial/01-svelte/06-bindings/01-text-inputs/index.md)

[//]: # ()
[//]: # (--- title: Text inputs --- As a general rule, data flow in Svelte is _top down_ — a parent component can set props on a child component, and a component can set attributes on an element, but not the other way around. Sometimes it's useful to break that rule. Take the case of the `<input>` element in this component — we _could_ add an `oninput` event handler that sets the value of `name` to `event.target.value`, but it's a bit... boilerplatey. It gets even worse with other form elements, as we'll see. Instead, we can use the `bind:value` directive: `svelte /// file: App.svelte <inputbind:value={name}> ` This means that not only will changes to the value of `name` update the input value, but changes to the input value will update `name`.)

[//]: # ()
[//]: # (## tutorial/01-svelte/06-bindings/02-numeric-inputs/index.md)

[//]: # ()
[//]: # (--- title: Numeric inputs --- In the DOM, every input value is a string. That's unhelpful when you're dealing with numeric inputs — `type="number"` and `type="range"` — as it means you have to remember to coerce `input.value` before using it. With `bind:value`, Svelte takes care of it for you: `svelte /// file: App.svelte <label> <input type="number"bind:value={a} min="0" max="10" /> <input type="range"bind:value={a} min="0" max="10" /> </label> <label> <input type="number"bind:value={b} min="0" max="10" /> <input type="range"bind:value={b} min="0" max="10" /> </label> `)

[//]: # ()
[//]: # (## tutorial/01-svelte/06-bindings/03-checkbox-inputs/index.md)

[//]: # ()
[//]: # (--- title: Checkbox inputs --- Checkboxes are used for toggling between states. Instead of binding to `input.value`, we bind to `input.checked`: `svelte /// file: App.svelte <input type="checkbox"bind:checked={yes}> `)

[//]: # ()
[//]: # (## tutorial/01-svelte/06-bindings/04-select-bindings/index.md)

[//]: # ()
[//]: # (--- title: Select bindings --- We can also use `bind:value` with `<select>` elements: `svelte /// file: App.svelte <select bind:value={selected} onchange={&#40;&#41; => answer = ''} > ` Note that the `<option>` values are objects rather than strings. Svelte doesn't mind.)

[//]: # ()
[//]: # (## tutorial/01-svelte/06-bindings/05-group-inputs/index.md)

[//]: # ()
[//]: # (--- title: Group inputs --- If you have multiple `type="radio"` or `type="checkbox"` inputs relating to the same value, you can use `bind:group` along with the `value` attribute. Radio inputs in the same group are mutually exclusive; checkbox inputs in the same group form an array of selected values. Add `bind:group={scoops}` to the radio inputs... `svelte /// file: App.svelte <input type="radio" name="scoops" value={number} bind:group={scoops} /> ` ...and `bind:group={flavours}` to the checkbox inputs: `svelte /// file: App.svelte <input type="checkbox" name="flavours" value={flavour} bind:group={flavours} /> `)

[//]: # ()
[//]: # (## tutorial/01-svelte/06-bindings/06-multiple-select-bindings/index.md)

[//]: # ()
[//]: # (--- title: Select multiple --- A `<select>` element can have a `multiple` attribute, in which case it will populate an array rather than selecting a single value. Replace the checkboxes with a `<select multiple>`: `svelte /// file: App.svelte <h2>Flavours</h2> <select multiple bind:value={flavours}> {#each ['cookies and cream', 'mint choc chip', 'raspberry ripple'] as flavour} <option>{flavour}</option> {/each} </select> ` Note that we're able to omit the `value` attribute on the `<option>`, since the value is identical to the element's contents.)

[//]: # ()
[//]: # (## tutorial/01-svelte/06-bindings/07-textarea-inputs/index.md)

[//]: # ()
[//]: # (--- title: Textarea inputs --- The `<textarea>` element behaves similarly to a text input in Svelte — use `bind:value`: `svelte /// file: App.svelte <textareabind:value={value}></textarea> ` In cases like these, where the names match, we can also use a shorthand form: `svelte /// file: App.svelte <textareabind:value></textarea> ` This applies to all bindings, not just `<textarea>` bindings.)

[//]: # ()
[//]: # (## tutorial/01-svelte/07-classes-and-styles/index.md)

[//]: # ()
[//]: # (--- title: Classes and styles scope: { 'prefix': '/src/lib/', 'name': 'src' } focus: /src/lib/App.svelte ---)

[//]: # ()
[//]: # (## tutorial/01-svelte/07-classes-and-styles/01-classes/index.md)

[//]: # ()
[//]: # (--- title: The class attribute --- Like any other attribute, you can specify classes with a JavaScript attribute. Here, we could add a `flipped` class to the card: `svelte /// file: App.svelte <button class="card {flipped ? 'flipped' : ''}" onclick={&#40;&#41; => flipped = !flipped} > ` This works as expected — if you click on the card now, it'll flip. We can make it nicer though. Adding or removing a class based on some condition is such a common pattern in UI development that Svelte allows you to pass an object or array that is converted to a string by [clsx]&#40;https://github.com/lukeed/clsx&#41;. `svelte /// file: App.svelte <button class={["card", { flipped }]} onclick={&#40;&#41; => flipped = !flipped} > ` This means 'always add the `card` class, and add the `flipped` class whenever `flipped` is truthy'. For more examples of how to combine conditional classes, [consult the `class` documentation]&#40;/docs/svelte/class&#41;.)

[//]: # ()
[//]: # (## tutorial/01-svelte/07-classes-and-styles/02-styles/index.md)

[//]: # ()
[//]: # (--- title: The style directive --- As with `class`, you can write your inline `style` attributes literally, because Svelte is really just HTML with fancy bits: `svelte /// file: App.svelte <button class="card" style="transform: {flipped ? 'rotateY&#40;0&#41;' : ''}; --bg-1: palegoldenrod; --bg-2: black; --bg-3: goldenrod" onclick={&#40;&#41; => flipped = !flipped} > ` When you have a lot of styles, it can start to look a bit wacky. We can tidy things up by using the `style:` directive: `svelte /// file: App.svelte <button class="card" style:transform={flipped ? 'rotateY&#40;0&#41;' : ''} style:--bg-1="palegoldenrod" style:--bg-2="black" style:--bg-3="goldenrod" onclick={&#40;&#41; => flipped = !flipped} > `)

[//]: # ()
[//]: # (## tutorial/01-svelte/07-classes-and-styles/03-component-styles/index.md)

[//]: # ()
[//]: # (--- title: Component styles --- Often, you need to influence the styles inside a child component. Perhaps we want to make these boxes red, green and blue. One way to do this is with the `:global` CSS modifier, which allows you to indiscriminately target elements inside other components: `svelte /// file: App.svelte <style> .boxes :global&#40;.box:nth-child&#40;1&#41;&#41; { background-color: red; } .boxes :global&#40;.box:nth-child&#40;2&#41;&#41; { background-color: green; } .boxes :global&#40;.box:nth-child&#40;3&#41;&#41; { background-color: blue; } </style> ` But there are lots of reasons _not_ to do that. For one thing, it's extremely verbose. For another, it's brittle — any changes to the implementation details of `Box.svelte` could break the selector. Most of all though, it's rude. Components should be able to decide for themselves which styles can be controlled from 'outside', in the same way they decide which variables are exposed as props. `:global` should be used as an escape hatch — a last resort. Inside `Box.svelte`, change `background-color` so that it is determined by a [CSS custom property]&#40;https://developer.mozilla.org/en-US/docs/Web/CSS/--*&#41;: `svelte /// file: Box.svelte <style> .box { width: 5em; height: 5em; border-radius: 0.5em; margin: 0 0 1em 0; background-color:var&#40;--color, #ddd&#41;; } </style> ` Any parent element &#40;such as `<div class="boxes">`&#41; can set the value of `--color`, but we can also set it on individual components: `svelte /// file: App.svelte <div class="boxes"> <Box--color="red"/> <Box--color="green"/> <Box--color="blue"/> </div> ` The values can be dynamic, like any other attribute. > > `svelte > <svelte-css-wrapper style="display: contents; --color: red;"> > > </svelte-css-wrapper> > ` > > Because of `display: contents` this won't affect your layout, but the extra element _can_ affect selectors like `.parent > .child`.)

[//]: # ()
[//]: # (## tutorial/01-svelte/08-actions/index.md)

[//]: # ()
[//]: # (--- title: Actions scope: { 'prefix': '/src/lib/', 'name': 'src' } focus: /src/lib/App.svelte ---)

[//]: # ()
[//]: # (## tutorial/01-svelte/08-actions/01-actions/index.md)

[//]: # ()
[//]: # (--- title: The use directive --- Actions are essentially element-level lifecycle functions. They're useful for things like: - interfacing with third-party libraries - lazy-loaded images - tooltips - adding custom event handlers In this app, you can scribble on the `<canvas>`, and change colours and brush size via the menu. But if you open the menu and cycle through the options with the Tab key, you'll soon find that the focus isn't _trapped_ inside the modal. We can fix that with an action. Import `trapFocus` from `actions.svelte.js`... `svelte /// file: App.svelte <script> import Canvas from './Canvas.svelte'; import { trapFocus } from './actions.svelte.js'; const colors = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet', 'white', 'black']; let selected = $state&#40;colors[0]&#41;; let size = $state&#40;10&#41;; let showMenu = $state&#40;true&#41;; </script> ` ...then add it to the menu with the `use:` directive: `svelte /// file: App.svelte <div class="menu"use:trapFocus> ` Let's take a look at the `trapFocus` function in `actions.svelte.js`. An action function is called with a `node` — the `<div class="menu">` in our case — when the node is mounted to the DOM. Inside the action, we have an [effect]&#40;effects&#41;. First, we need to add an event listener that intercepts Tab key presses: `js /// file: actions.svelte.js $effect&#40;&#40;&#41; => { focusable&#40;&#41;[0]?.focus&#40;&#41;; node.addEventListener&#40;'keydown', handleKeydown&#41;; }&#41;; ` Second, we need to do some cleanup when the node is unmounted — removing the event listener, and restoring focus to where it was before the element mounted: `js /// file: actions.svelte.js $effect&#40;&#40;&#41; => { focusable&#40;&#41;[0]?.focus&#40;&#41;; node.addEventListener&#40;'keydown', handleKeydown&#41;; return &#40;&#41; => { node.removeEventListener&#40;'keydown', handleKeydown&#41;; previous?.focus&#40;&#41;; }; }&#41;; ` Now, when you open the menu, you can cycle through the options with the Tab key.)

[//]: # ()
[//]: # (## tutorial/01-svelte/08-actions/02-adding-parameters-to-actions/index.md)

[//]: # ()
[//]: # (--- title: Adding parameters --- Like transitions and animations, an action can take an argument, which the action function will be called with alongside the element it belongs to. In this exercise, we want to add a tooltip to the `<button>` using the [`Tippy.js`]&#40;https://atomiks.github.io/tippyjs/&#41; library. The action is already wired up with `use:tooltip`, but if you hover over the button &#40;or focus it with the keyboard&#41; the tooltip contains no content. First, the action needs to accept a function that returns some options to pass to Tippy: `js /// file: App.svelte function tooltip&#40;node,fn&#41; { $effect&#40;&#40;&#41; => { const tooltip = tippy&#40;node,fn&#40;&#41;&#41;; return tooltip.destroy; }&#41;; } ` Then, we need to pass the options into the action: `svelte /// file: App.svelte <button use:tooltip={&#40;&#41; => &#40;{ content }&#41;}> Hover me </button> `)

[//]: # ()
[//]: # (## tutorial/01-svelte/09-transitions/index.md)

[//]: # ()
[//]: # (--- title: Transitions scope: { 'prefix': '/src/lib/', 'name': 'src' } focus: /src/lib/App.svelte ---)

[//]: # ()
[//]: # (## tutorial/01-svelte/09-transitions/01-transition/index.md)

[//]: # ()
[//]: # (--- title: The transition directive --- We can make more appealing user interfaces by gracefully transitioning elements into and out of the DOM. Svelte makes this very easy with the `transition` directive. First, import the `fade` function from `svelte/transition`... `svelte /// file: App.svelte <script> import { fade } from 'svelte/transition'; let visible = $state&#40;true&#41;; </script> ` ...then add it to the `<p>` element: `svelte /// file: App.svelte <ptransition:fade> Fades in and out </p> `)

[//]: # ()
[//]: # (## tutorial/01-svelte/09-transitions/02-adding-parameters-to-transitions/index.md)

[//]: # ()
[//]: # (--- title: Adding parameters --- Transition functions can accept parameters. Replace the `fade` transition with `fly`... `svelte /// file: App.svelte <script> import {fly} from 'svelte/transition'; let visible = $state&#40;true&#41;; </script> ` ...and apply it to the `<p>` along with some options: `svelte /// file: App.svelte <p transition:fly={{ y: 200, duration: 2000 }}> Fliesin and out </p> ` Note that the transition is _reversible_ — if you toggle the checkbox while the transition is ongoing, it transitions from the current point, rather than the beginning or the end.)

[//]: # ()
[//]: # (## tutorial/01-svelte/09-transitions/03-in-and-out/index.md)

[//]: # ()
[//]: # (--- title: In and out --- Instead of the `transition` directive, an element can have an `in` or an `out` directive, or both together. Import `fade` alongside `fly`... `js /// file: App.svelte import {fade, fly } from 'svelte/transition'; ` ...then replace the `transition` directive with separate `in` and `out` directives: `svelte /// file: App.svelte <pin:fly={{ y: 200, duration: 2000 }}out:fade> Flies in,fades out </p> ` In this case, the transitions are _not_ reversed.)

[//]: # ()
[//]: # (## tutorial/01-svelte/09-transitions/04-custom-css-transitions/index.md)

[//]: # ()
[//]: # (--- title: Custom CSS transitions --- The `svelte/transition` module has a handful of built-in transitions, but it's very easy to create your own. By way of example, this is the source of the `fade` transition: ``js function fade&#40;node, { delay = 0, duration = 400 }&#41; { const o = +getComputedStyle&#40;node&#41;.opacity; return { delay, duration, css: &#40;t&#41; => `opacity: ${t * o}` }; } `` The function takes two arguments — the node to which the transition is applied, and any parameters that were passed in — and returns a transition object which can have the following properties: - `delay` — milliseconds before the transition begins - `duration` — length of the transition in milliseconds - `easing` — a `p => t` easing function &#40;see the chapter on [tweening]&#40;/tutorial/svelte/tweens&#41;&#41; - `css` — a `&#40;t, u&#41; => css` function, where `u === 1 - t` - `tick` — a `&#40;t, u&#41; => {...}` function that has some effect on the node The `t` value is `0` at the beginning of an intro or the end of an outro, and `1` at the end of an intro or beginning of an outro. Most of the time you should return the `css` property and _not_ the `tick` property, as CSS animations run off the main thread to prevent jank where possible. Svelte 'simulates' the transition and constructs a CSS animation, then lets it run. For example, the `fade` transition generates a CSS animation somewhat like this: `css 0% { opacity: 0 } 10% { opacity: 0.1 } 20% { opacity: 0.2 } /* ... */ 100% { opacity: 1 } ` We can get a lot more creative though. Let's make something truly gratuitous: ``svelte /// file: App.svelte <script> import { fade } from 'svelte/transition'; import { elasticOut } from 'svelte/easing'; let visible = $state&#40;true&#41;; function spin&#40;node, { duration }&#41; { return { duration, css: &#40;t, u&#41; =>{ const eased = elasticOut&#40;t&#41;; return ` transform: scale&#40;${eased}&#41; rotate&#40;${eased * 1080}deg&#41;; color: hsl&#40; ${Math.trunc&#40;t * 360&#41;}, ${Math.min&#40;100, 1000 * u&#41;}%, ${Math.min&#40;50, 500 * u&#41;}% &#41;;` } }; } </script> `` Remember: with great power comes great responsibility.)

[//]: # ()
[//]: # (## tutorial/01-svelte/09-transitions/05-custom-js-transitions/index.md)

[//]: # ()
[//]: # (--- title: Custom JS transitions --- While you should generally use CSS for transitions as much as possible, there are some effects that can't be achieved without JavaScript, such as a typewriter effect: ``js /// file: App.svelte function typewriter&#40;node, { speed = 1 }&#41; { const valid = node.childNodes.length === 1 && node.childNodes[0].nodeType === Node.TEXT_NODE; if &#40;!valid&#41; { throw new Error&#40;`This transition only works on elements with a single text node child`&#41;; } const text = node.textContent; const duration = text.length / &#40;speed * 0.01&#41;; return { duration, tick: &#40;t&#41; => { const i = Math.trunc&#40;text.length * t&#41;; node.textContent = text.slice&#40;0, i&#41;; } }; } ``)

[//]: # ()
[//]: # (## tutorial/01-svelte/09-transitions/06-transition-events/index.md)

[//]: # ()
[//]: # (--- title: Transition events --- It can be useful to know when transitions are beginning and ending. Svelte dispatches events that you can listen to like any other DOM event: `svelte /// file: App.svelte <p transition:fly={{ y: 200, duration: 2000 }} onintrostart={&#40;&#41; => status = 'intro started'} onoutrostart={&#40;&#41; => status = 'outro started'} onintroend={&#40;&#41; => status = 'intro ended'} onoutroend={&#40;&#41; => status = 'outro ended'} > Flies in and out </p> `)

[//]: # ()
[//]: # (## tutorial/01-svelte/09-transitions/07-global-transitions/index.md)

[//]: # ()
[//]: # (--- title: Global transitions --- Ordinarily, transitions will only play on elements when their direct containing block is added or destroyed. In the example here, toggling the visibility of the entire list does not apply transitions to individual list elements. Instead, we'd like transitions to not only play when individual items are added and removed with the slider but also when we toggle the checkbox. We can achieve this with a _global_ transition, which plays when _any_ block containing the transitions is added or removed: `svelte /// file: App.svelte <div transition:slide|global> {item} </div> `)

[//]: # ()
[//]: # (## tutorial/01-svelte/09-transitions/08-key-blocks/index.md)

[//]: # ()
[//]: # (--- title: Key blocks --- Key blocks destroy and recreate their contents when the value of an expression changes. This is useful if you want an element to play its transition whenever a value changes instead of only when the element enters or leaves the DOM. Here, for example, we'd like to play the `typewriter` transition from `transition.js` whenever the loading message, i.e. `i` changes. Wrap the `<p>` element in a key block: `svelte /// file: App.svelte {#key i} <p in:typewriter={{ speed: 10 }}> {messages[i] || ''} </p> {/key} `)

[//]: # ()
[//]: # (## tutorial/02-advanced-svelte/index.md)

[//]: # ()
[//]: # (--- title: Advanced Svelte label: Part 2 scope: { 'prefix': '/src/lib/', 'name': 'src' } focus: /src/lib/App.svelte ---)

[//]: # ()
[//]: # (## tutorial/02-advanced-svelte/01-advanced-reactivity/index.md)

[//]: # ()
[//]: # (--- title: Advanced reactivity scope: { 'prefix': '/src/lib/', 'name': 'src' } focus: /src/lib/App.svelte ---)

[//]: # ()
[//]: # (## tutorial/02-advanced-svelte/01-advanced-reactivity/01-raw-state/index.md)

[//]: # ()
[//]: # (--- title: Raw state --- In previous exercises, we learned that state is [deeply reactive]&#40;deep-state&#41; — if you &#40;for example&#41; change a property of an object, or push to an array, it will cause the UI to update. This works by creating a [proxy]&#40;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy&#41; that intercepts reads and writes. Occasionally, that's not what you want. If you're not changing individual properties, or if it's important to maintain referential equality, then you can use _raw state_ instead. In this example, we have a chart of Svelte's steadily increasing stock price. We want the chart to update when new data comes in, which we could achieve by turning `data` into state... `js /// file: App.svelte let data =$state&#40;poll&#40;&#41;&#41;; ` ...but there's no need to make it deeply reactive when it will be discarded a few milliseconds later. Instead, use `$state.raw`: `js /// file: App.svelte let data =$state.raw&#40;poll&#40;&#41;&#41;; `)

[//]: # ()
[//]: # (## tutorial/02-advanced-svelte/01-advanced-reactivity/02-reactive-classes/index.md)

[//]: # ()
[//]: # (--- title: Reactive classes --- It's not just variables that can be made reactive — in Svelte, we can also make properties of classes reactive. Let's make the `width` and `height` properties of our `Box` class reactive: `js /// file: App.svelte class Box { width =$state&#40;0&#41;; height =$state&#40;0&#41;; area = 0; // ... } ` Now, when we interact with the range inputs or click the 'embiggen' button, the box reacts. We can also use `$derived`, so that `box.area` updates reactively: `js /// file: App.svelte class Box { width = $state&#40;0&#41;; height = $state&#40;0&#41;; area =$derived&#40;this.width * this.height&#41;; // ... } `)

[//]: # ()
[//]: # (## tutorial/02-advanced-svelte/01-advanced-reactivity/03-getters-and-setters/index.md)

[//]: # ()
[//]: # (--- title: Getters and setters --- Classes are particularly useful when you need to validate data. In the case of this `Box` class, it shouldn't be possible to keep embiggening past the maximum allowed by the sliders, but that's exactly what happens. We can fix that by replacing `width` and `height` with _getters_ and _setters_, otherwise known as _accessors_. First, convert them to [private properties]&#40;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Private_properties&#41;: `js /// file: App.svelte class Box { #width= $state&#40;0&#41;; #height= $state&#40;0&#41;; area = $derived&#40;this.#width* this.#height&#41;; constructor&#40;width, height&#41; { this.#width= width; this.#height= height; } // ... } ` Then, create some getters and setters: `js /// file: App.svelte class Box { // ... get width&#40;&#41; { return this.#width; } get height&#40;&#41; { return this.#height; } set width&#40;value&#41; { this.#width = value; } set height&#40;value&#41; { this.#height = value; } embiggen&#40;amount&#41; { this.width += amount; this.height += amount; } } ` Finally, add the validation to the setters: `js /// file: App.svelte set width&#40;value&#41; { this.#width =Math.max&#40;0, Math.min&#40;MAX_SIZE, value&#41;&#41;; } set height&#40;value&#41; { this.#height =Math.max&#40;0, Math.min&#40;MAX_SIZE, value&#41;&#41;; } ` It's now impossible to increase the box size past safe limits, whether through the `bind:value` on the range inputs, or the `embiggen` method, no matter how hard you press the button.)

[//]: # ()
[//]: # (## tutorial/02-advanced-svelte/01-advanced-reactivity/04-reactive-builtins/index.md)

[//]: # ()
[//]: # (--- title: Reactive built-ins --- Svelte ships with several reactive classes that you can use in place of JavaScript built-in objects — namely `Map`, `Set`, `Date`, `URL` and `URLSearchParams`. In this exercise, we _could_ declare `date` using `$state&#40;new Date&#40;&#41;&#41;` and reassign it inside the `setInterval`. But a nicer alternative is to use `SvelteDate` from [`svelte/reactivity`]&#40;/docs/svelte/svelte-reactivity&#41;: `svelte /// file: App.svelte <script> import { SvelteDate } from 'svelte/reactivity'; let date = newSvelteDate&#40;&#41;; // ... </script> `)

[//]: # ()
[//]: # (## tutorial/02-advanced-svelte/01-advanced-reactivity/05-stores/index.md)

[//]: # ()
[//]: # (--- title: Stores --- Prior to the introduction of runes in Svelte 5, stores were the idiomatic way to handle reactive state outside components. That's no longer the case, but you'll still encounter stores when using Svelte &#40;including in SvelteKit, for now&#41;, so it's worth knowing how to use them. Let's revisit the example from the [universal reactivity]&#40;universal-reactivity&#41; exercise, but this time implement the shared state using a store. In `shared.js` we're currently exporting `count`, which is a number. Turn it into a writable store: `js /// file: shared.js import { writable } from 'svelte/store'; export const count =writable&#40;0&#41;; ` To reference the value of the store, we prefix it with a `$` symbol. In `Counter.svelte`, update the text inside the `<button>` so that it no longer says `[object Object]`: `svelte /// file: Counter.svelte <button onclick={&#40;&#41; => {}}> clicks: {$count} </button> ` Finally, add the event handler. Because this is a writable store, we can update the value programmatically using its `set` or `update` method... `js count.update&#40;&#40;n&#41; => n + 1&#41;; ` ...but since we're in a component we can continue using the `$` prefix: `svelte /// file: Counter.svelte <button onclick={&#40;&#41; =>$count += 1}> clicks: {$count} </button> `)

[//]: # ()
[//]: # (## tutorial/02-advanced-svelte/02-snippets/index.md)

[//]: # ()
[//]: # (--- title: Reusing content scope: { 'prefix': '/src/lib/', 'name': 'src' } focus: /src/lib/App.svelte ---)

[//]: # ()
[//]: # (## tutorial/02-advanced-svelte/02-snippets/01-snippets-and-render-tags/index.md)

[//]: # ()
[//]: # (--- title: Snippets and render tags --- Snippets allow you to reuse content within a component, without extracting it out into a separate file. In this exercise, we're creating a table of the [three wise monkeys]&#40;https://en.wikipedia.org/wiki/Three_wise_monkeys&#41;, along with their unicode escape sequences and HTML entities. So far, we have but a single monkey. We could duplicate the markup, of course. Or we could create an array of `{ emoji, description }` objects and pass it into an `{#each ...}` block. But a neater solution is to encapsulate the markup in a reusable block. Begin by _declaring a snippet_: `svelte /// file: App.svelte {#snippet monkey&#40;&#41;} <tr> <td>{emoji}</td> <td>{description}</td> <td>\u{emoji.charCodeAt&#40;0&#41;.toString&#40;16&#41;}\u{emoji.charCodeAt&#40;1&#41;.toString&#40;16&#41;}</td> <td>&amp#{emoji.codePointAt&#40;0&#41;}</td> </tr> {/snippet} ` The monkey is no longer visible until we _render_ it. Let's do that: `svelte /// file: App.svelte <tbody> {#snippet monkey&#40;&#41;}...{/snippet} {@render monkey&#40;&#41;} </tbody> ` Before we can use the snippet for the rest of our monkeys, we need to pass data into the snippet. Snippets can have zero or more parameters: `svelte /// file: App.svelte <tbody> {#snippet monkey&#40;emoji, description&#41;}...{/snippet} {@render monkey&#40;'🙈', 'see no evil'&#41;} </tbody> ` Add the rest of the monkeys: - `'🙈', 'see no evil'` - `'🙉', 'hear no evil'` - `'🙊', 'speak no evil'` Finally, delete the `<script>` block we no longer need it: `svelte /// file: App.svelte <script> let emoji = '🙈'; let description = 'see no evil'; </script> `)

[//]: # ()
[//]: # (## tutorial/02-advanced-svelte/02-snippets/02-passing-snippets/index.md)

[//]: # ()
[//]: # (--- title: Passing snippets to components --- Since snippets — like functions — are just values, they can be passed to components as props. Take this `<FilteredList>` component. Its job is to filter the `data` that gets passed into it, but it has no opinions about how that data should be rendered — that's the responsibility of the parent component. We've already got some snippets defined. Begin by passing them into the `<FilteredList>`: `svelte /// file: App.svelte <FilteredList data={colors} field="name" {header} {row} ></FilteredList> ` Then, on the other side, declare `header` and `row` as props: `svelte /// file: FilteredList.svelte <script> let { data, field,header, row} = $props&#40;&#41;; // ... </script> ` Finally, replace the placeholder content with render tags: `svelte /// file: FilteredList.svelte <div class="header"> {@render header&#40;&#41;} </div> <div class="content"> {#each filtered as d} {@render row&#40;d&#41;} {/each} </div> ` Never again will you have to memorize the hex code for `MistyRose` or `PeachPuff`.)

[//]: # ()
[//]: # (## tutorial/02-advanced-svelte/02-snippets/03-implicit-snippet-props/index.md)

[//]: # ()
[//]: # (--- title: Implicit snippet props --- As an authoring convenience, snippets declared directly inside components become props _on_ those components. Take the `header` and `row` snippets and move them inside `<FilteredList>`: `svelte /// file: App.svelte <FilteredList data={colors} field="name" {header} {row} > {#snippet header&#40;&#41;}...{/snippet} {#snippet row&#40;d&#41;}...{/snippet} </FilteredList> {#snippet header&#40;&#41;}...{/snippet} {#snippet row&#40;d&#41;}...{/snippet} ` We can now remove them from the explicit props: `svelte /// file: App.svelte <FilteredList data={colors} field="name"{header} {row}> {#snippet header&#40;&#41;}...{/snippet} {#snippet row&#40;d&#41;}...{/snippet} </FilteredList> ` Any content inside a component that is _not_ part of a declared snippet becomes a special `children` snippet. Since `header` has no parameters, we can turn it into `children` by removing the block tags... `svelte /// file: App.svelte {#snippet header&#40;&#41;} <header> <span class="color"></span> <span class="name">name</span> <span class="hex">hex</span> <span class="rgb">rgb</span> <span class="hsl">hsl</span> </header> {/snippet} ` ...and renaming the `header` prop to `children` on the other side: `svelte /// file: FilteredList.svelte <script> let { data, field,children, row } = $props&#40;&#41;; // ... </script> ` `svelte /// file: FilteredList.svelte <div class="header"> {@render children&#40;&#41;} </div> `)

[//]: # ()
[//]: # (## tutorial/02-advanced-svelte/03-motion/index.md)

[//]: # ()
[//]: # (--- title: Motion scope: { 'prefix': '/src/lib/', 'name': 'src' } focus: /src/lib/App.svelte ---)

[//]: # ()
[//]: # (## tutorial/02-advanced-svelte/03-motion/01-tweens/index.md)

[//]: # ()
[//]: # (--- title: Tweened values --- Often, a good way to communicate that a value is changing is to use _motion_. Svelte ships classes for adding motion to your user interfaces. Import the `Tween` class from `svelte/motion`: `svelte /// file: App.svelte <script> import { Tween } from 'svelte/motion'; let progress = $state&#40;0&#41;; </script> ` Turn `progress` into an instance of `Tween`: `svelte /// file: App.svelte <script> import { Tween } from 'svelte/motion'; let progress =new Tween&#40;0&#41;; </script> ` The `Tween` class has a writable `target` property and a readonly `current` property — update the `<progress>` element... `svelte <progress value={progress.current}></progress> ` ...and each of the event handlers: `svelte <button onclick={&#40;&#41; => &#40;progress.target= 0&#41;}> 0% </button> ` Clicking the buttons causes the progress bar to animate to its new value. It's a bit robotic and unsatisfying though. We need to add an easing function: `svelte /// file: App.svelte <script> import { Tween } from 'svelte/motion'; import { cubicOut } from 'svelte/easing'; let progress = new Tween&#40;0,{ duration: 400, easing: cubicOut }&#41;; </script> ` The full set of options available to `Tween`: - `delay` — milliseconds before the tween starts - `duration` — either the duration of the tween in milliseconds, or a `&#40;from, to&#41; => milliseconds` function allowing you to &#40;e.g.&#41; specify longer tweens for larger changes in value - `easing` — a `p => t` function - `interpolate` — a custom `&#40;from, to&#41; => t => value` function for interpolating between arbitrary values. By default, Svelte will interpolate between numbers, dates, and identically-shaped arrays and objects &#40;as long as they only contain numbers and dates or other valid arrays and objects&#41;. If you want to interpolate &#40;for example&#41; colour strings or transformation matrices, supply a custom interpolator You can also call `progress.set&#40;value, options&#41;` instead of assigning directly to `progress.target`, in which case `options` will override the defaults. The `set` method returns a promise that resolves when the tween completes.)

[//]: # ()
[//]: # (## tutorial/02-advanced-svelte/03-motion/02-springs/index.md)

[//]: # ()
[//]: # (--- title: Springs --- The `Spring` class is an alternative to `Tween` that often works better for values that are frequently changing. In this example we have a circle that follows the mouse, and two values — the circle's coordinates, and its size. Let's convert them to springs: `svelte /// file: App.svelte <script> import { Spring } from 'svelte/motion'; let coords =new Spring&#40;{ x: 50, y: 50 }&#41;; let size =new Spring&#40;10&#41;; </script> ` As with `Tween`, springs have a writable `target` property and a readonly `current` property. Update the event handlers... `svelte <svg onmousemove={&#40;e&#41; => { coords.target= { x: e.clientX, y: e.clientY }; }} onmousedown={&#40;&#41; => &#40;size.target= 30&#41;} onmouseup={&#40;&#41; => &#40;size.target= 10&#41;} role="presentation" > ` ...and the `<circle>` attributes: `svelte <circle cx={coords.current.x} cy={coords.current.y} r={size.current} ></circle> ` Both springs have default `stiffness` and `damping` values, which control the spring's, well... springiness. We can specify our own initial values: `js /// file: App.svelte let coords = new Spring&#40;{ x: 50, y: 50 },{ stiffness: 0.1, damping: 0.25 }&#41;; ` Waggle your mouse around, and try dragging the sliders to get a feel for how they affect the spring's behaviour. Notice that you can adjust the values while the spring is still in motion.)

[//]: # ()
[//]: # (## tutorial/02-advanced-svelte/04-advanced-bindings/index.md)

[//]: # ()
[//]: # (--- title: Advanced bindings scope: { 'prefix': '/src/lib/', 'name': 'src' } focus: /src/lib/App.svelte ---)

[//]: # ()
[//]: # (## tutorial/02-advanced-svelte/04-advanced-bindings/01-contenteditable-bindings/index.md)

[//]: # ()
[//]: # (--- title: Contenteditable bindings --- Elements with a `contenteditable` attribute support `textContent` and `innerHTML` bindings: `svelte /// file: App.svelte <divbind:innerHTML={html}contenteditable></div> `)

[//]: # ()
[//]: # (## tutorial/02-advanced-svelte/04-advanced-bindings/02-each-block-bindings/index.md)

[//]: # ()
[//]: # (--- title: Each block bindings --- You can bind to properties inside an `each` block. `svelte /// file: App.svelte {#each todos as todo} <li class={{ done: todo.done }}> <input type="checkbox" bind:checked={todo.done} /> <input type="text" placeholder="What needs to be done?" bind:value={todo.text} /> </li> {/each} `)

[//]: # ()
[//]: # (## tutorial/02-advanced-svelte/04-advanced-bindings/03-media-elements/index.md)

[//]: # ()
[//]: # (--- title: Media elements --- You can bind to properties of `<audio>` and `<video>` elements, making it easy to &#40;for example&#41; build custom player UI, like `AudioPlayer.svelte`. First, add the `<audio>` element along with its bindings &#40;we'll use the shorthand form for `src`, `duration` and `paused`&#41;: `svelte /// file: AudioPlayer.svelte <div class={['player', { paused }]}> <audio {src} bind:currentTime={time} bind:duration bind:paused ></audio> <button class="play" aria-label={paused ? 'play' : 'pause'} ></button> ` Next, add an event handler to the `<button>` that toggles `paused`: `svelte /// file: AudioPlayer.svelte <button class="play" aria-label={paused ? 'play' : 'pause'} onclick={&#40;&#41; => paused = !paused} ></button> ` Our audio player now has basic functionality. Let's add the ability to seek to a specific part of a track by dragging the slider. Inside the slider's `pointerdown` handler there's a `seek` function, where we can update `time`: `js /// file: AudioPlayer.svelte function seek&#40;e&#41; { const { left, width } = div.getBoundingClientRect&#40;&#41;; let p = &#40;e.clientX - left&#41; / width; if &#40;p < 0&#41; p = 0; if &#40;p > 1&#41; p = 1; time = p * duration; } ` When the track ends, be kind — rewind: `svelte /// file: AudioPlayer.svelte <audio {src} bind:currentTime={time} bind:duration bind:paused onended={&#40;&#41; => { time = 0; }} ></audio> ` The complete set of bindings for `<audio>` and `<video>` is as follows — seven _readonly_ bindings... - `duration` — the total duration, in seconds - `buffered` — an array of `{start, end}` objects - `seekable` — ditto - `played` — ditto - `seeking` — boolean - `ended` — boolean - `readyState` — number between &#40;and including&#41; 0 and 4 ...and five _two-way_ bindings: - `currentTime` — the current position of the playhead, in seconds - `playbackRate` — speed up or slow down &#40;`1` is 'normal'&#41; - `paused` — this one should be self-explanatory - `volume` — a value between 0 and 1 - `muted` — a boolean value where true is muted Videos additionally have readonly `videoWidth` and `videoHeight` bindings.)

[//]: # ()
[//]: # (## tutorial/02-advanced-svelte/04-advanced-bindings/04-dimensions/index.md)

[//]: # ()
[//]: # (--- title: Dimensions --- You can add `clientWidth`, `clientHeight`, `offsetWidth` and `offsetHeight` bindings to any element, and Svelte will update the bound values using a [`ResizeObserver`]&#40;https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver&#41;: `svelte /// file: App.svelte <divbind:clientWidth={w} bind:clientHeight={h}> <span style="font-size: {size}px" contenteditable>{text}</span> <span class="size">{w} x {h}px</span> </div> ` These bindings are readonly — changing the values of `w` and `h` won't have any effect on the element.)

[//]: # ()
[//]: # (## tutorial/02-advanced-svelte/04-advanced-bindings/05-bind-this/index.md)

[//]: # ()
[//]: # (--- title: This --- You can use the special `bind:this` directive to get a readonly binding to an element in your component. The `$effect` in this exercise attempts to create a canvas context, but `canvas` is `undefined`. Begin by declaring it at the top level of the component... `svelte /// file: App.svelte <script> import { paint } from './gradient.js'; let canvas; $effect&#40;&#40;&#41; => { // ... }&#41;; </script> ` ...then add the directive to the `<canvas>` element: `svelte /// file: App.svelte <canvasbind:this={canvas}width={32} height={32}></canvas> ` Note that the value of `canvas` will remain `undefined` until the component has mounted — in other words you can't access it until the `$effect` runs.)

[//]: # ()
[//]: # (## tutorial/02-advanced-svelte/04-advanced-bindings/06-component-bindings/index.md)

[//]: # ()
[//]: # (--- title: Component bindings --- Just as you can bind to properties of DOM elements, you can bind to component props. For example, we can bind to the `value` prop of this `<Keypad>` component as though it were a form element. First, we need to mark the prop as _bindable_. Inside `Keypad.svelte`, update the `$props&#40;&#41;` declaration to use the `$bindable` rune: `js /// file: Keypad.svelte let { value= $bindable&#40;''&#41;, onsubmit } = $props&#40;&#41;; ` Then, in `App.svelte`, add a `bind:` directive: `svelte /// file: App.svelte <Keypadbind:value={pin}{onsubmit} /> ` Now, when the user interacts with the keypad, the value of `pin` in the parent component is immediately updated.)

[//]: # ()
[//]: # (## tutorial/02-advanced-svelte/04-advanced-bindings/07-component-this/index.md)

[//]: # ()
[//]: # (--- title: Binding to component instances --- Just as you can bind to DOM elements, you can bind to component instances themselves with `bind:this`. This is useful in the rare cases that you need to interact with a component programmatically &#40;rather than by providing it with updated props&#41;. Revisiting our canvas app from [a few exercises ago]&#40;actions&#41;, it would be nice to add a button to clear the screen. First, let's export a function from `Canvas.svelte`: `svelte /// file: Canvas.svelte let canvas = $state&#40;&#41;; let context = $state&#40;&#41;; let coords = $state&#40;&#41;; export function clear&#40;&#41; { context.clearRect&#40;0, 0, canvas.width, canvas.height&#41;; } ` Then, create a reference to the component instance: `js /// file: App.svelte let selected = $state&#40;colors[0]&#41;; let size = $state&#40;10&#41;; let showMenu = $state&#40;true&#41;; let canvas; ` `svelte /// file: App.svelte <Canvasbind:this={canvas}color={selected} size={size} /> ` Finally, add a button that calls the `clear` function: `svelte /// file: App.svelte <div class="controls"> <button class="show-menu" onclick={&#40;&#41; => showMenu = !showMenu}> {showMenu ? 'close' : 'menu'} </button> <button onclick={&#40;&#41; => canvas.clear&#40;&#41;}> clear </button> </div> `)

[//]: # ()
[//]: # (## tutorial/02-advanced-svelte/05-advanced-transitions/index.md)

[//]: # ()
[//]: # (--- title: Advanced transitions scope: { 'prefix': '/src/lib/', 'name': 'src' } focus: /src/lib/App.svelte ---)

[//]: # ()
[//]: # (## tutorial/02-advanced-svelte/05-advanced-transitions/01-deferred-transitions/index.md)

[//]: # ()
[//]: # (--- title: Deferred transitions --- A particularly powerful feature of Svelte's transition engine is the ability to _defer_ transitions, so that they can be coordinated between multiple elements. Take this pair of todo lists, in which toggling a todo sends it to the opposite list. In the real world, objects don't behave like that — instead of disappearing and reappearing in another place, they move through a series of intermediate positions. Using motion can go a long way towards helping users understand what's happening in your app. We can achieve this effect using the `crossfade` function, as seen in `transition.js`, which creates a pair of transitions called `send` and `receive`. When an element is 'sent', it looks for a corresponding element being 'received', and generates a transition that transforms the element to its counterpart's position and fades it out. When an element is 'received', the reverse happens. If there is no counterpart, the `fallback` transition is used. Open `TodoList.svelte`. First, import the `send` and `receive` transitions from transition.js: `svelte /// file: TodoList.svelte <script> import { send, receive } from './transition.js'; let { todos, remove } = $props&#40;&#41;; </script> ` Then, add them to the `<li>` element, using the `todo.id` property as a key to match the elements: `svelte /// file: TodoList.svelte <li class={{ done: todo.done }} in:receive={{ key: todo.id }} out:send={{ key: todo.id }} > ` Now, when you toggle items, they move smoothly to their new location. The non-transitioning items still jump around awkwardly — we can fix that in the next exercise.)

[//]: # ()
[//]: # (## tutorial/02-advanced-svelte/05-advanced-transitions/02-animations/index.md)

[//]: # ()
[//]: # (--- title: Animations --- In the [previous chapter]&#40;/tutorial/svelte/deferred-transitions&#41;, we used deferred transitions to create the illusion of motion as elements move from one todo list to the other. To complete the illusion, we also need to apply motion to the elements that _aren't_ transitioning. For this, we use the `animate` directive. First, import the `flip` function — flip stands for ['First, Last, Invert, Play']&#40;https://aerotwist.com/blog/flip-your-animations/&#41; — from `svelte/animate` into `TodoList.svelte`: `svelte /// file: TodoList.svelte <script> import { flip } from 'svelte/animate'; import { send, receive } from './transition.js'; let { todos, remove } = $props&#40;&#41;; </script> ` Then add it to the `<li>` elements: `svelte /// file: TodoList.svelte <li class={{ done: todo.done }} in:receive={{ key: todo.id }} out:send={{ key: todo.id }} animate:flip > ` The movement is a little slow in this case, so we can add a `duration` parameter: `svelte /// file: TodoList.svelte <li class={{ done: todo.done }} in:receive={{ key: todo.id }} out:send={{ key: todo.id }} animate:flip={{ duration: 200 }} > ` Note that all the transitions and animations are being applied with CSS, rather than JavaScript, meaning they won't block &#40;or be blocked by&#41; the main thread.)

[//]: # ()
[//]: # (## tutorial/02-advanced-svelte/06-context/index.md)

[//]: # ()
[//]: # (--- title: Context API scope: { 'prefix': '/src/lib/', 'name': 'src' } focus: /src/lib/App.svelte ---)

[//]: # ()
[//]: # (## tutorial/02-advanced-svelte/06-context/01-context-api/index.md)

[//]: # ()
[//]: # (--- title: setContext and getContext --- The context API provides a mechanism for components to 'talk' to each other without passing around data and functions as props, or dispatching lots of events. It's an advanced feature, but a useful one. In this exercise, we're going to recreate [Schotter]&#40;https://collections.vam.ac.uk/item/O221321/schotter-print-nees-georg/&#41; by George Nees — one of the pioneers of generative art — using the context API. Inside `Canvas.svelte`, there's an `addItem` function that adds an item to the canvas. We can make it available to components inside `<Canvas>`, like `<Square>`, with `setContext`: `js /// file: Canvas.svelte import { setContext } from 'svelte'; import { SvelteSet } from 'svelte/reactivity'; let { width = 100, height = 100, children } = $props&#40;&#41;; let canvas; let items = new SvelteSet&#40;&#41;; setContext&#40;'canvas', { addItem }&#41;; function addItem&#40;fn&#41; { $effect&#40;&#40;&#41; => { items.add&#40;fn&#41;; return &#40;&#41; => items.delete&#40;fn&#41;; }&#41;; } ` Inside child components, we can now get the context with, well, `getContext`: `js /// file: Square.svelte import { getContext } from 'svelte'; let { x, y, size, rotate } = $props&#40;&#41;; getContext&#40;'canvas'&#41;.addItem&#40;draw&#41;; ` So far, so... boring. Let's add some randomness to the grid: `svelte /// file: App.svelte <div class="container"> <Canvas width={800} height={1200}> {#each Array&#40;12&#41; as _, c} {#each Array&#40;22&#41; as _, r} <Square x={180 + c * 40+ jitter&#40;r * 2&#41;} y={180 + r * 40+ jitter&#40;r * 2&#41;} size={40} rotate={jitter&#40;r * 0.05&#41;} /> {/each} {/each} </Canvas> </div> ` `setContext` and `getContext` must be called during component initialisation, so that the context can be correctly bound. The key — `'canvas'` in this case — can be anything you like, including non-strings, which is useful for controlling who can access the context. > > `js > // in a parent component > import { setContext } from 'svelte'; > > let context = $state&#40;{...}&#41;; > setContext&#40;'my-context', context&#41;; > ` > > `js > // in a child component > import { getContext } from 'svelte'; > > const context = getContext&#40;'my-context'&#41;; > `)

[//]: # ()
[//]: # (## tutorial/02-advanced-svelte/07-special-elements/index.md)

[//]: # ()
[//]: # (--- title: Special elements scope: { 'prefix': '/src/lib/', 'name': 'src' } focus: /src/lib/App.svelte ---)

[//]: # ()
[//]: # (## tutorial/02-advanced-svelte/07-special-elements/01-svelte-window/index.md)

[//]: # ()
[//]: # (--- title: <svelte:window> --- Just as you can add event listeners to any DOM element, you can add event listeners to the `window` object with `<svelte:window>`. We've already got an `onkeydown` function declared — now all we need to do is wire it up: `svelte /// file: App.svelte <svelte:window{onkeydown}/> `)

[//]: # ()
[//]: # (## tutorial/02-advanced-svelte/07-special-elements/02-svelte-window-bindings/index.md)

[//]: # ()
[//]: # (--- title: <svelte:window> bindings --- We can also bind to certain properties of `window`, such as `scrollY`: `svelte /// file: App.svelte <svelte:windowbind:scrollY={y}/> ` The list of properties you can bind to is as follows: - `innerWidth` - `innerHeight` - `outerWidth` - `outerHeight` - `scrollX` - `scrollY` - `online` — an alias for `window.navigator.onLine` All except `scrollX` and `scrollY` are readonly.)

[//]: # ()
[//]: # (## tutorial/02-advanced-svelte/07-special-elements/03-svelte-document/index.md)

[//]: # ()
[//]: # (--- title: <svelte:document> --- The `<svelte:document>` element allows you to listen for events that fire on `document`. This is useful with events like `selectionchange`, which doesn't fire on `window`. Add the `onselectionchange` handler to the `<svelte:document>` tag: `svelte /// file: App.svelte <svelte:document{onselectionchange}/> `)

[//]: # ()
[//]: # (## tutorial/02-advanced-svelte/07-special-elements/04-svelte-body/index.md)

[//]: # ()
[//]: # (--- title: <svelte:body> --- Similar to `<svelte:window>` and `<svelte:document>`, the `<svelte:body>` element allows you to listen for events that fire on `document.body`. This is useful with the `mouseenter` and `mouseleave` events, which don't fire on `window`. Add `onmouseenter` and `onmouseleave` handlers to the `<svelte:body>` tag... `svelte /// file: App.svelte <svelte:body onmouseenter={&#40;&#41; => hereKitty = true} onmouseleave={&#40;&#41; => hereKitty = false} /> ` ...and hover over the `<body>`.)

[//]: # ()
[//]: # (## tutorial/02-advanced-svelte/07-special-elements/05-svelte-head/index.md)

[//]: # ()
[//]: # (--- title: <svelte:head> --- The `<svelte:head>` element allows you to insert elements inside the `<head>` of your document. This is useful for things like `<title>` and `<meta>` tags, which are critical for good SEO. Since those are quite hard to show in the context of this tutorial, we'll use it for a different purpose — loading stylesheets. `svelte /// file: App.svelte <script> const themes = ['margaritaville', 'retrowave', 'spaaaaace', 'halloween']; let selected = $state&#40;themes[0]&#41;; </script> <svelte:head> <link rel="stylesheet" href="/tutorial/stylesheets/{selected}.css" /> </svelte:head> <h1>Welcome to my site!</h1> `)

[//]: # ()
[//]: # (## tutorial/02-advanced-svelte/07-special-elements/06-svelte-element/index.md)

[//]: # ()
[//]: # (--- title: <svelte:element> --- Sometimes you don't know in advance which element needs to be rendered. Rather than having a long list of `{#if ...}` blocks... `svelte /// file: App.svelte {#if selected === 'h1'} <h1>I'm a <code>&lt;h1&gt;</code> element</h1> {:else} <p>TODO others</p> {/if} ` ...we can use `<svelte:element>`: `svelte /// file: App.svelte <svelte:element this={selected}> I'm a <code>&lt;{selected}&gt;</code> element </svelte:element> ` The `this` value can be any string, or a falsy value — if it's falsy, no element is rendered.)

[//]: # ()
[//]: # (## tutorial/02-advanced-svelte/07-special-elements/07-svelte-boundary/index.md)

[//]: # ()
[//]: # (--- title: <svelte:boundary> --- To prevent errors from leaving your app in a broken state, you can contain them inside an _error boundary_ using the `<svelte:boundary>` element. In this example, `<FlakyComponent>` contains a bug — clicking the button will set `mouse` to `null`, meaning that the `{mouse.x}` and `{mouse.y}` expressions in the template will fail to render. In an ideal world we'd simply fix the bug. But that's not always an option — sometimes the component belongs to someone else, and sometimes you just need to guard against the unexpected. Begin by wrapping `<FlakyComponent />` with `<svelte:boundary>`: `svelte <!file: App.svelte> <svelte:boundary> <FlakyComponent /> </svelte:boundary> ` So far, nothing has changed, because the boundary doesn't specify a handler. Add a `failed` [snippet]&#40;snippets-and-render-tags&#41; to provide some UI to show when an error occurs: `svelte <!file: App.svelte> <svelte:boundary> <FlakyComponent /> {#snippet failed&#40;error&#41;} <p>Oops! {error.message}</p> {/snippet} </svelte:boundary> ` Now, when we click the button, the contents of the boundary are replaced with the snippet. We can attempt to reset things by making use of the second argument passed to `failed`: `svelte <!file: App.svelte> <svelte:boundary> <FlakyComponent /> {#snippet failed&#40;error, reset&#41;} <p>Oops! {error.message}</p> <button onclick={reset}>Reset</button> {/snippet} </svelte:boundary> ` We can also specify an `onerror` handler, which is called with the same arguments passed to the `failed` snippet: `svelte <!file: App.svelte> <svelte:boundaryonerror={&#40;e&#41; => console.error&#40;e&#41;}> <FlakyComponent /> {#snippet failed&#40;error, reset&#41;} <p>Oops! {error.message}</p> <button onclick={reset}>Reset</button> {/snippet} </svelte:boundary> ` This is useful for sending information about the error to a reporting service, or adding UI outside the error boundary itself.)

[//]: # ()
[//]: # (## tutorial/02-advanced-svelte/08-script-module/index.md)

[//]: # ()
[//]: # (--- title: <script module> scope: { 'prefix': '/src/lib/', 'name': 'src' } focus: /src/lib/App.svelte ---)

[//]: # ()
[//]: # (## tutorial/02-advanced-svelte/08-script-module/01-sharing-code/index.md)

[//]: # ()
[//]: # (--- title: Sharing code --- In all the examples we've seen so far, the `<script>` block contains code that runs when each component instance is initialised. For the vast majority of components, that's all you'll ever need. Very occasionally, you'll need to run some code outside of an individual component instance. For example: returning to our custom audio player from a [previous exercise]&#40;media-elements&#41;, you can play all four tracks simultaneously. It would be better if playing one stopped all the others. We can do that by declaring a `<script module>` block. Code contained inside it will run once, when the module first evaluates, rather than when a component is instantiated. Place this at the top of `AudioPlayer.svelte` &#40;note that this is a _separate_ script tag&#41;: `svelte /// file: AudioPlayer.svelte <script module> let current; </script> ` It's now possible for the components to 'talk' to each other without any state management: `svelte /// file: AudioPlayer.svelte <audio src={src} bind:currentTime={time} bind:duration bind:paused onplay={&#40;e&#41; => { const audio = e.currentTarget; if &#40;audio !== current&#41; { current?.pause&#40;&#41;; current = audio; } }} onended={&#40;&#41; => { time = 0; }} /> `)

[//]: # ()
[//]: # (## tutorial/02-advanced-svelte/08-script-module/02-module-exports/index.md)

[//]: # ()
[//]: # (--- title: Exports --- Anything exported from a `module` script block becomes an export from the module itself. Let's export a `stopAll` function: `svelte /// file: AudioPlayer.svelte <script module> let current; export function stopAll&#40;&#41; { current?.pause&#40;&#41;; } </script> ` We can now import `stopAll` in `App.svelte`... `svelte /// file: App.svelte <script> import AudioPlayer,{ stopAll }from './AudioPlayer.svelte'; import { tracks } from './tracks.js'; </script> ` ...and use it in an event handler: `svelte /// file: App.svelte <div class="centered"> {#each tracks as track} <AudioPlayer {...track} /> {/each} <button onclick={stopAll}> stop all </button> </div> `)

[//]: # ()
[//]: # (## tutorial/02-advanced-svelte/09-next-steps/index.md)

[//]: # ()
[//]: # (--- title: Next steps scope: { 'prefix': '/src/lib/', 'name': 'src' } focus: /src/lib/App.svelte ---)

[//]: # ()
[//]: # (## tutorial/02-advanced-svelte/09-next-steps/01-congratulations/index.md)

[//]: # ()
[//]: # (--- title: Congratulations! --- You've now finished the Svelte tutorial and are ready to start building. The next two parts of the tutorial will focus on SvelteKit, a full-fledged framework for creating apps of all shapes and sizes. If you're suffering from information overload and aren't ready to go through the SvelteKit tutorial yet, don't worry! You can use your existing Svelte knowledge without learning all of SvelteKit. Just run this in your terminal and follow the prompts... `bash npx sv create ` ...and start editing `src/routes/+page.svelte`. When you're ready, click the link below to continue your journey.)

[//]: # ()
[//]: # (## tutorial/02-advanced-svelte/xx-currently-unused/01-debug/index.md)

[//]: # ()
[//]: # (--- title: The @debug tag --- Occasionally, it's useful to inspect a piece of data as it flows through your app. One approach is to use `console.log&#40;...&#41;` inside your markup. If you want to pause execution, though, you can use the `{@debug ...}` tag with a comma-separated list of values you want to inspect: `svelte /// file: App.svelte {@debug user} <h1>Hello {user.firstname}!</h1> ` If you now open your devtools and start interacting with the `<input>` elements, you'll trigger the debugger as the value of `user` changes. &#40;Note that the call stack and local variables will be hidden in this tutorial, because of iframe security restrictions.&#41;)

[//]: # ()
[//]: # (## tutorial/02-advanced-svelte/xx-currently-unused/01-svelte-self/index.md)

[//]: # ()
[//]: # (--- title: <svelte:self> --- Svelte provides a variety of built-in elements. The first, `<svelte:self>`, allows a component to contain itself recursively. It's useful for things like this folder tree view, where folders can contain _other_ folders. In `Folder.svelte` we want to be able to do this... `svelte /// file: Folder.svelte {#if file.files} <Folder {...file}/> {:else} <File {...file}/> {/if} ` ...but that's impossible, because a module can't import itself. Instead, we use `<svelte:self>`: `svelte /// file: Folder.svelte {#if file.files} <svelte:self {...file} /> {:else} <File {...file} /> {/if} `)

[//]: # ()
[//]: # (## tutorial/03-sveltekit/index.md)

[//]: # ()
[//]: # (--- title: Basic SvelteKit label: Part 3 scope: { 'prefix': '/', 'name': 'project' } focus: /src/routes/+page.svelte ---)

[//]: # ()
[//]: # (## tutorial/03-sveltekit/01-concepts/index.md)

[//]: # ()
[//]: # (--- title: Introduction ---)

[//]: # ()
[//]: # (## tutorial/03-sveltekit/01-concepts/01-introducing-sveltekit/index.md)

[//]: # ()
[//]: # (--- title: What is SvelteKit? --- Whereas Svelte is a _component framework_, SvelteKit is an _app framework_ &#40;or 'metaframework', depending on who you ask&#41; that solves the tricky problems of building something production-ready: - Routing - Server-side rendering - Data fetching - Service workers - TypeScript integration - Prerendering - Single-page apps - Library packaging - Optimised production builds - Deploying to different hosting providers - ...and so on SvelteKit apps are server-rendered by default &#40;like traditional 'multi-page apps' or MPAs&#41; for excellent first load performance and SEO characteristics, but can then transition to client-side navigation &#40;like modern 'single-page apps' or SPAs&#41; to avoid jankily reloading everything &#40;including things like third-party analytics code&#41; when the user navigates. They can run anywhere JavaScript runs, though — as we'll see — your users may not need to run any JavaScript at all. If that sounds complicated, worry not: SvelteKit is the framework that grows with you! Start simple and add new features as you need them. ## Project structure On the right, in the file tree viewer, you'll see a handful of files that SvelteKit expects to find in a project. `package.json` will be familiar if you've worked with Node.js before. It lists the project's dependencies — including `svelte` and `@sveltejs/kit` — and a variety of `scripts` for interacting with the SvelteKit CLI. &#40;We're currently running `npm run dev` in the bottom window.&#41; `svelte.config.js` contains your project configuration. We don't need to worry about this file for now, but if you're curious, [visit the documentation]&#40;/docs/kit/configuration&#41;. `vite.config.js` contains the [Vite]&#40;https://vitejs.dev/&#41; configuration. Because SvelteKit uses Vite, you can use [Vite features]&#40;https://vitejs.dev/guide/features.html&#41; like hot module replacement, TypeScript support, static asset handling and so on. `src` is where your app's source code goes. `src/app.html` is your page template &#40;SvelteKit replaces the `%sveltekit.head%` and `%sveltekit.body%` as appropriate&#41;, and `src/routes` defines the [routes]&#40;/tutorial/kit/pages&#41; of your app. Finally, `static` contains any assets &#40;like a `favicon.png` or a `robots.txt`&#41; that should be included when your app is deployed.)

[//]: # ()
[//]: # (## tutorial/03-sveltekit/02-routing/index.md)

[//]: # ()
[//]: # (--- title: Routing ---)

[//]: # ()
[//]: # (## tutorial/03-sveltekit/02-routing/01-pages/index.md)

[//]: # ()
[//]: # (--- title: Pages --- SvelteKit uses filesystem-based routing, which means that the _routes_ of your app — in other words, what the app should do when a user navigates to a particular URL — are defined by the directories in your codebase. Every `+page.svelte` file inside `src/routes` creates a page in your app. In this app we currently have one page — `src/routes/+page.svelte`, which maps to `/`. If we navigate to `/about`, we'll see a 404 Not Found error. Let's fix that. Add a second page, `src/routes/about/+page.svelte`, copy the contents of `src/routes/+page.svelte`, and update it: `svelte /// file: src/routes/about/+page.svelte <nav> <a href="/">home</a> <a href="/about">about</a> </nav> <h1>about</h1> <p>this is theaboutpage.</p> ` We can now navigate between `/` and `/about`.)

[//]: # ()
[//]: # (## tutorial/03-sveltekit/02-routing/02-layouts/index.md)

[//]: # ()
[//]: # (--- title: Layouts --- Different routes of your app will often share common UI. Instead of repeating it in each `+page.svelte` component, we can use a `+layout.svelte` component that applies to all routes in the same directory. In this app we have two routes, `src/routes/+page.svelte` and `src/routes/about/+page.svelte`, that contain the same navigation UI. Let's create a new file, `src/routes/+layout.svelte`... `src/routes/ ├ about/ │ └ +page.svelte ├ +layout.svelte └ +page.svelte` ...and move the duplicated content from the `+page.svelte` files into the new `+layout.svelte` file. The `{@render children&#40;&#41;}` tag is where the page content will be rendered: `svelte /// file: src/routes/+layout.svelte <script> let { children } = $props&#40;&#41;; </script> <nav> <a href="/">home</a> <a href="/about">about</a> </nav> {@render children&#40;&#41;} ` A `+layout.svelte` file applies to every child route, including the sibling `+page.svelte` &#40;if it exists&#41;. You can nest layouts to arbitrary depth.)

[//]: # ()
[//]: # (## tutorial/03-sveltekit/02-routing/03-params/index.md)

[//]: # ()
[//]: # (--- title: Route parameters path: /blog --- To create routes with dynamic parameters, use square brackets around a valid variable name. For example, a file like `src/routes/blog/[slug]/+page.svelte` will create a route that matches `/blog/one`, `/blog/two`, `/blog/three` and so on. Let's create that file: `svelte /// file: src/routes/blog/[slug]/+page.svelte <h1>blog post</h1> ` We can now navigate from the `/blog` page to individual blog posts. In the next chapter, we'll see how to load their content.)

[//]: # ()
[//]: # (## tutorial/03-sveltekit/03-loading-data/index.md)

[//]: # ()
[//]: # (--- title: Loading data ---)

[//]: # ()
[//]: # (## tutorial/03-sveltekit/03-loading-data/01-page-data/index.md)

[//]: # ()
[//]: # (--- title: Page data path: /blog --- At its core, SvelteKit's job boils down to three things: 1. **Routing** — figure out which route matches an incoming request 2. **Loading** — get the data needed by the route 3. **Rendering** — generate some HTML &#40;on the server&#41; or update the DOM &#40;in the browser&#41; We've seen how routing and rendering work. Let's talk about the middle part — loading. Every page of your app can declare a `load` function in a `+page.server.js` file alongside the `+page.svelte` file. As the file name suggests, this module only ever runs on the server, including for client-side navigations. Let's add a `src/routes/blog/+page.server.js` file so that we can replace the hard-coded links in `src/routes/blog/+page.svelte` with actual blog post data: `js /// file: src/routes/blog/+page.server.js import { posts } from './data.js'; export function load&#40;&#41; { return { summaries: posts.map&#40;&#40;post&#41; => &#40;{ slug: post.slug, title: post.title }&#41;&#41; }; } ` We can access this data in `src/routes/blog/+page.svelte` via the `data` prop: `svelte /// file: src/routes/blog/+page.svelte <script> let { data } = $props&#40;&#41;; </script> <h1>blog</h1> <ul> <li><a href="/blog/one">one</a></li> <li><a href="/blog/two">two</a></li> <li><a href="/blog/three">three</a></li> {#each data.summaries as { slug, title }} <li><a href="/blog/{slug}">{title}</a></li> {/each} </ul> ` Now, let's do the same for the post page: `js /// file: src/routes/blog/[slug]/+page.server.js import { posts } from '../data.js'; export function load&#40;{ params }&#41; { const post = posts.find&#40;&#40;post&#41; => post.slug === params.slug&#41;; return { post }; } ` `svelte /// file: src/routes/blog/[slug]/+page.svelte <script> let { data } = $props&#40;&#41;; </script> <h1>blog post</h1> <h1>{data.post.title}</h1> <div>{@html data.post.content}</div> ` There's one last detail we need to take care of — the user might visit an invalid pathname like `/blog/nope`, in which case we'd like to respond with a 404 page: `js /// file: src/routes/blog/[slug]/+page.server.js import { error } from '@sveltejs/kit'; import { posts } from '../data.js'; export function load&#40;{ params }&#41; { const post = posts.find&#40;&#40;post&#41; => post.slug === params.slug&#41;; if &#40;!post&#41; error&#40;404&#41;; return { post }; } ` We'll learn more about error handling in later chapters.)

[//]: # ()
[//]: # (## tutorial/03-sveltekit/03-loading-data/02-layout-data/index.md)

[//]: # ()
[//]: # (--- title: Layout data path: /blog --- Just as `+layout.svelte` files create UI for every child route, `+layout.server.js` files load data for every child route. Suppose we'd like to add a 'more posts' sidebar to our blog post page. We _could_ return `summaries` from the `load` function in `src/routes/blog/[slug]/+page.server.js`, like we do in `src/routes/blog/+page.server.js`, but that would be repetitive. Instead, let's rename `src/routes/blog/+page.server.js` to `src/routes/blog/+layout.server.js`. Notice that the `/blog` route continues to work — `data.summaries` is still available to the page. Now, add a sidebar in the layout for the post page: `svelte /// file: src/routes/blog/[slug]/+layout.svelte <script> let { data, children } = $props&#40;&#41;; </script> <div class="layout"> <main> {@render children&#40;&#41;} </main> <aside> <h2>More posts</h2> <ul> {#each data.summaries as { slug, title }} <li> <a href="/blog/{slug}">{title}</a> </li> {/each} </ul> </aside> </div> <style> @media &#40;min-width: 640px&#41; { .layout { display: grid; gap: 2em; grid-template-columns: 1fr 16em; } } </style> ` The layout &#40;and any page below it&#41; inherits `data.summaries` from the parent `+layout.server.js`. When we navigate from one post to another, we only need to load the data for the post itself — the layout data is still valid. See the documentation on [invalidation]&#40;/docs/kit/load#Rerunning-load-functions&#41; to learn more.)

[//]: # ()
[//]: # (## tutorial/03-sveltekit/04-headers-and-cookies/index.md)

[//]: # ()
[//]: # (--- title: Headers and cookies ---)

[//]: # ()
[//]: # (## tutorial/03-sveltekit/04-headers-and-cookies/01-headers/index.md)

[//]: # ()
[//]: # (--- title: Setting headers --- Inside a `load` function &#40;as well as in [form actions]&#40;the-form-element&#41;, [hooks]&#40;handle&#41; and [API routes]&#40;get-handlers&#41;, which we'll learn about later&#41; you have access to a `setHeaders` function, which — unsurprisingly — can be used to set headers on the response. Most commonly, you'd use it to customise caching behaviour with the [`Cache-Control`]&#40;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control&#41; response header, but for the sake of this tutorial we'll do something less advisable and more dramatic: `js /// file: src/routes/+page.server.js export function load&#40;{ setHeaders }&#41; { setHeaders&#40;{ 'Content-Type': 'text/plain' }&#41;; } ` &#40;You may need to reload the iframe to see the effect.&#41;)

[//]: # ()
[//]: # (## tutorial/03-sveltekit/04-headers-and-cookies/02-cookies/index.md)

[//]: # ()
[//]: # (--- title: Reading and writing cookies --- The [`setHeaders`]&#40;headers&#41; function can't be used with the `Set-Cookie` header. Instead, you should use the `cookies` API. In your `load` functions, you can read a cookie with `cookies.get&#40;name, options&#41;`: `js /// file: src/routes/+page.server.js export function load&#40;{ cookies }&#41; { const visited = cookies.get&#40;'visited'&#41;; return { visited: visited === 'true' }; } ` To set a cookie, use `cookies.set&#40;name, value, options&#41;`. It's strongly recommended that you explicitly configure the `path` when setting a cookie, since browsers' default behaviour — somewhat uselessly — is to set the cookie on the parent of the current path. `js /// file: src/routes/+page.server.js export function load&#40;{ cookies }&#41; { const visited = cookies.get&#40;'visited'&#41;; cookies.set&#40;'visited', 'true', { path: '/' }&#41;; return { visited: visited === 'true' }; } ` Now, if you reload the iframe, `Hello stranger!` becomes `Hello friend!`. Calling `cookies.set&#40;name, ...&#41;` causes a `Set-Cookie` header to be written, but it _also_ updates the internal map of cookies, meaning any subsequent calls to `cookies.get&#40;name&#41;` during the same request will return the updated value. Under the hood, the `cookies` API uses the popular `cookie` package — the options passed to `cookies.get` and `cookies.set` correspond to the `parse` and `serialize` options from the `cookie` [documentation]&#40;https://github.com/jshttp/cookie#api&#41;. SvelteKit sets the following defaults to make your cookies more secure: `js { httpOnly: true, secure: true, sameSite: 'lax' } `)

[//]: # ()
[//]: # (## tutorial/03-sveltekit/05-shared-modules/index.md)

[//]: # ()
[//]: # (--- title: Shared modules ---)

[//]: # ()
[//]: # (## tutorial/03-sveltekit/05-shared-modules/01-lib/index.md)

[//]: # ()
[//]: # (--- title: The $lib alias --- Because SvelteKit uses directory-based routing, it's easy to place modules and components alongside the routes that use them. A good rule of thumb is 'put code close to where it's used'. Sometimes, code is used in multiple places. When this happens, it's useful to have a place to put them that can be accessed by all routes without needing to prefix imports with `../../../../`. In SvelteKit, that place is the `src/lib` directory. Anything inside this directory can be accessed by any module in `src` via the `$lib`alias. Both`+page.svelte`files in this exercise import`src/lib/message.js`. But if you navigate to `/a/deeply/nested/route`, the app breaks, because we got the prefix wrong. Update it to use `$lib/message.js` instead: ```svelte /// file: src/routes/a/deeply/nested/route/+page.svelte <script> import { message } from'$lib/message.js'; </script> <h1>a deeply nested route</h1> <p>{message}</p> ``Do the same for `src/routes/+page.svelte`:``svelte /// file: src/routes/+page.svelte <script> import { message } from'$lib/message.js'; </script> <h1>home</h1> <p>{message}</p> ```)

[//]: # ()
[//]: # (## tutorial/03-sveltekit/06-forms/index.md)

[//]: # ()
[//]: # (--- title: Forms ---)

[//]: # ()
[//]: # (## tutorial/03-sveltekit/06-forms/01-the-form-element/index.md)

[//]: # ()
[//]: # (--- title: The <form> element --- In the chapter on [loading data]&#40;page-data&#41;, we saw how to get data from the server to the browser. Sometimes you need to send data in the opposite direction, and that's where `<form>` — the web platform's way of submitting data — comes in. Let's build a todo app. We've already got an in-memory database set up in `src/lib/server/database.js`, and our `load` function in `src/routes/+page.server.js` uses the [`cookies`]&#40;/docs/kit/load#Cookies&#41; API so that we can have a per-user todo list, but we need to add a `<form>` to create new todos: `svelte /// file: src/routes/+page.svelte <h1>todos</h1> <form method="POST"> <label> add a todo: <input name="description" autocomplete="off" /> </label> </form> <ul class="todos"> ` If we type something into the `<input>` and hit Enter, the browser makes a POST request &#40;because of the `method="POST"` attribute&#41; to the current page. But that results in an error, because we haven't created a server-side _action_ to handle the POST request. Let's do that now: `js /// file: src/routes/+page.server.js import * as db from '$lib/server/database.js'; export function load&#40;{ cookies }&#41; { // ... } export const actions = { default: async &#40;{ cookies, request }&#41; => { const data = await request.formData&#40;&#41;; db.createTodo&#40;cookies.get&#40;'userid'&#41;, data.get&#40;'description'&#41;&#41;; } }; ` The `request` is a standard [Request]&#40;https://developer.mozilla.org/en-US/docs/Web/API/Request&#41; object; `await request.formData&#40;&#41;` returns a [`FormData`]&#40;https://developer.mozilla.org/en-US/docs/Web/API/FormData&#41; instance. When we hit Enter, the database is updated and the page reloads with the new data. Notice that we haven't had to write any `fetch` code or anything like that — data updates automatically. And because we're using a `<form>` element, this app would work even if JavaScript was disabled or unavailable.)

[//]: # ()
[//]: # (## tutorial/03-sveltekit/06-forms/02-named-form-actions/index.md)

[//]: # ()
[//]: # (--- title: Named form actions --- A page that only has a single action is, in practice, quite rare. Most of the time you'll need to have multiple actions on a page. In this app, creating a todo isn't enough — we'd like to delete them once they're complete. Begin by replacing our `default` action with named `create` and `delete` actions: `js /// file: src/routes/+page.server.js export const actions = { create: async &#40;{ cookies, request }&#41; => { const data = await request.formData&#40;&#41;; db.createTodo&#40;cookies.get&#40;'userid'&#41;, data.get&#40;'description'&#41;&#41;; }, delete: async &#40;{ cookies, request }&#41; => { const data = await request.formData&#40;&#41;; db.deleteTodo&#40;cookies.get&#40;'userid'&#41;, data.get&#40;'id'&#41;&#41;; } }; ` The `<form>` element has an optional `action` attribute, which is similar to an `<a>` element's `href` attribute. Update the existing form so that it points to the new `create` action: `svelte /// file: src/routes/+page.svelte <form method="POST"action="?/create"> <label> add a todo: <input name="description" autocomplete="off" /> </label> </form> ` Next, we want to create a form for each todo, complete with a hidden `<input>` that uniquely identifies it: `svelte /// file: src/routes/+page.svelte <ul class="todos"> {#each data.todos as todo &#40;todo.id&#41;} <li> <form method="POST" action="?/delete"> <input type="hidden" name="id" value={todo.id} /> <span>{todo.description}</span> <button aria-label="Mark as complete"></button> </form> </li> {/each} </ul> `)

[//]: # ()
[//]: # (## tutorial/03-sveltekit/06-forms/03-form-validation/index.md)

[//]: # ()
[//]: # (--- title: Validation --- Users are a mischievous bunch, who will submit all kinds of nonsensical data if given the chance. To prevent them from causing chaos, it's important to validate form data. The first line of defense is the browser's [built-in form validation]&#40;https://developer.mozilla.org/en-US/docs/Learn/Forms/Form_validation#using_built-in_form_validation&#41;, which makes it easy to, for example, mark an `<input>` as required: `svelte /// file: src/routes/+page.svelte <form method="POST" action="?/create"> <label> add a todo <input name="description" autocomplete="off" required /> </label> </form> ` Try hitting Enter while the `<input>` is empty. This kind of validation is helpful, but insufficient. Some validation rules &#40;e.g. uniqueness&#41; can't be expressed using `<input>` attributes, and in any case, if the user is an elite hacker they might simply delete the attributes using the browser's devtools. To guard against these sorts of shenanigans, you should always use server-side validation. In `src/lib/server/database.js`, validate that the description exists and is unique: `js /// file: src/lib/server/database.js export function createTodo&#40;userid, description&#41; { if &#40;description === ''&#41; { throw new Error&#40;'todo must have a description'&#41;; } const todos = db.get&#40;userid&#41;; if &#40;todos.find&#40;&#40;todo&#41; => todo.description === description&#41;&#41; { throw new Error&#40;'todos must be unique'&#41;; } todos.push&#40;{ id: crypto.randomUUID&#40;&#41;, description, done: false }&#41;; } ` Try submitting a duplicate todo. Yikes! SvelteKit takes us to an unfriendly-looking error page. On the server, we see a 'todos must be unique' error, but SvelteKit hides unexpected error messages from users because they often contain sensitive data. It would be much better to stay on the same page and provide an indication of what went wrong so that the user can fix it. To do this, we can use the `fail` function to return data from the action along with an appropriate HTTP status code: `js /// file: src/routes/+page.server.js import { fail } from '@sveltejs/kit'; import * as db from '$lib/server/database.js'; export function load&#40;{ cookies }&#41; {...} export const actions = { create: async &#40;{ cookies, request }&#41; => { const data = await request.formData&#40;&#41;; try { db.createTodo&#40;cookies.get&#40;'userid'&#41;, data.get&#40;'description'&#41;&#41;; } catch &#40;error&#41; { return fail&#40;422, { description: data.get&#40;'description'&#41;, error: error.message }&#41;; } } ` In `src/routes/+page.svelte`, we can access the returned value via the `form` prop, which is only ever populated after a form submission: `svelte /// file: src/routes/+page.svelte <script> let { data,form} = $props&#40;&#41;; </script> <div class="centered"> <h1>todos</h1> {#if form?.error} <p class="error">{form.error}</p> {/if} <form method="POST" action="?/create"> <label> add a todo: <input name="description" value={form?.description ?? ''} autocomplete="off" required /> </label> </form> `)

[//]: # ()
[//]: # (## tutorial/03-sveltekit/06-forms/04-progressive-enhancement/index.md)

[//]: # ()
[//]: # (--- title: Progressive enhancement --- Because we're using `<form>`, our app works even if the user doesn't have JavaScript &#40;[which happens more often than you probably think]&#40;https://kryogenix.org/code/browser/everyonehasjs.html&#41;&#41;. That's great, because it means our app is resilient. Most of the time, users _do_ have JavaScript. In those cases, we can _progressively enhance_ the experience, the same way SvelteKit progressively enhances `<a>` elements by using client-side routing. Import the `enhance` function from `$app/forms`... `svelte /// file: src/routes/+page.svelte <script> import { enhance } from '$app/forms'; let { data, form } = $props&#40;&#41;; </script> ` ...and add the `use:enhance` directive to the `<form>` elements: `svelte /// file: src/routes/+page.svelte <form method="POST" action="?/create"use:enhance> ` `svelte /// file: src/routes/+page.svelte <form method="POST" action="?/delete"use:enhance> ` And that's all it takes! Now, when JavaScript is enabled, `use:enhance` will emulate the browser-native behaviour except for the full-page reloads. It will: - update the `form` prop - invalidate all data on a successful response, causing `load` functions to re-run - navigate to the new page on a redirect response - render the nearest error page if an error occurs Now that we're updating the page rather than reloading it, we can get fancy with things like transitions: `svelte /// file: src/routes/+page.svelte <script> import { fly, slide } from 'svelte/transition'; import { enhance } from '$app/forms'; let { data, form } = $props&#40;&#41;; </script> ` `svelte /// file: src/routes/+page.svelte <liin:fly={{ y: 20 }} out:slide>...</li> `)

[//]: # ()
[//]: # (## tutorial/03-sveltekit/06-forms/05-customizing-use-enhance/index.md)

[//]: # ()
[//]: # (--- title: Customizing use:enhance --- With `use:enhance`, we can go further than just emulating the browser's native behaviour. By providing a callback, we can add things like **pending states** and **optimistic UI**. Let's simulate a slow network by adding an artificial delay to our two actions: `js /// file: src/routes/+page.server.js export const actions = { create: async &#40;{ cookies, request }&#41; => { await new Promise&#40;&#40;fulfil&#41; => setTimeout&#40;fulfil, 1000&#41;&#41;; ... }, delete: async &#40;{ cookies, request }&#41; => { await new Promise&#40;&#40;fulfil&#41; => setTimeout&#40;fulfil, 1000&#41;&#41;; ... } }; ` When we create or delete items, it now takes a full second before the UI updates, leaving the user wondering if they messed up somehow. To solve that, add some local state... `svelte /// file: src/routes/+page.svelte <script> import { fly, slide } from 'svelte/transition'; import { enhance } from '$app/forms'; let { data, form } = $props&#40;&#41;; let creating = $state&#40;false&#41;; let deleting = $state&#40;[]&#41;; </script> ` ...and toggle `creating` inside the first `use:enhance`: `svelte /// file: src/routes/+page.svelte <form method="POST" action="?/create" use:enhance={&#40;&#41; => { creating = true; return async &#40;{ update }&#41; => { await update&#40;&#41;; creating = false; }; }} > <label> add a todo: <input disabled={creating} name="description" value={form?.description ?? ''} autocomplete="off" required /> </label> </form> ` We can then show a message while we're saving data: `svelte /// file: src/routes/+page.svelte <ul class="todos"> </ul> {#if creating} <span class="saving">saving...</span> {/if} ` In the case of deletions, we don't really need to wait for the server to validate anything — we can just update the UI immediately: `svelte /// file: src/routes/+page.svelte <ul class="todos"> {#eachdata.todos.filter&#40;&#40;todo&#41; => !deleting.includes&#40;todo.id&#41;&#41;as todo &#40;todo.id&#41;} <li in:fly={{ y: 20 }} out:slide> <form method="POST" action="?/delete" use:enhance={&#40;&#41; => { deleting = [...deleting, todo.id]; return async &#40;{ update }&#41; => { await update&#40;&#41;; deleting = deleting.filter&#40;&#40;id&#41; => id !== todo.id&#41;; }; }} > <input type="hidden" name="id" value={todo.id} /> <button aria-label="Mark as complete">✔</button> {todo.description} </form> </li> {/each} </ul> `)

[//]: # ()
[//]: # (## tutorial/03-sveltekit/07-api-routes/index.md)

[//]: # ()
[//]: # (--- title: API routes ---)

[//]: # ()
[//]: # (## tutorial/03-sveltekit/07-api-routes/01-get-handlers/index.md)

[//]: # ()
[//]: # (--- title: GET handlers --- SvelteKit allows you to create more than just pages. We can also create _API routes_ by adding a `+server.js` file that exports functions corresponding to HTTP methods: `GET`, `PUT`, `POST`, `PATCH` and `DELETE`. This app fetches data from a `/roll` API route when you click the button. Create that route by adding a `src/routes/roll/+server.js` file: `js /// file: src/routes/roll/+server.js export function GET&#40;&#41; { const number = Math.floor&#40;Math.random&#40;&#41; * 6&#41; + 1; return new Response&#40;number, { headers: { 'Content-Type': 'application/json' } }&#41;; } ` Clicking the button now works. Request handlers must return a [Response]&#40;https://developer.mozilla.org/en-US/docs/Web/API/Response/Response&#41; object. Since it's common to return JSON from an API route, SvelteKit provides a convenience function for generating these responses: `js /// file: src/routes/roll/+server.js import { json } from '@sveltejs/kit'; export function GET&#40;&#41; { const number = Math.floor&#40;Math.random&#40;&#41; * 6&#41; + 1; return new Response&#40;number, { headers: { 'Content-Type': 'application/json' } }&#41;; return json&#40;number&#41;; } `)

[//]: # ()
[//]: # (## tutorial/03-sveltekit/07-api-routes/02-post-handlers/index.md)

[//]: # ()
[//]: # (--- title: POST handlers --- You can also add handlers that mutate data, such as `POST`. In most cases, you should use [form actions]&#40;the-form-element&#41; instead — you'll end up writing less code, and it'll work without JavaScript, making it more resilient. Inside the `keydown` event handler of the 'add a todo' `<input>`, let's post some data to the server: `svelte /// file: src/routes/+page.svelte <input type="text" autocomplete="off" onkeydown={async &#40;e&#41; => { if &#40;e.key !== 'Enter'&#41; return; const input = e.currentTarget; const description = input.value; const response = await fetch&#40;'/todo', { method: 'POST', body: JSON.stringify&#40;{ description }&#41;, headers: { 'Content-Type': 'application/json' } }&#41;; input.value = ''; }} /> ` Here, we're posting some JSON to the `/todo` API route — using a `userid` from the user's cookies — and receiving the `id` of the newly created todo in response. Create the `/todo` route by adding a `src/routes/todo/+server.js` file with a `POST` handler that calls `createTodo` in `src/lib/server/database.js`: `js /// file: src/routes/todo/+server.js import { json } from '@sveltejs/kit'; import * as database from '$lib/server/database.js'; export async function POST&#40;{ request, cookies }&#41; { const { description } = await request.json&#40;&#41;; const userid = cookies.get&#40;'userid'&#41;; const { id } = await database.createTodo&#40;{ userid, description }&#41;; return json&#40;{ id }, { status: 201 }&#41;; } ` As with `load` functions and form actions, the `request` is a standard [Request]&#40;https://developer.mozilla.org/en-US/docs/Web/API/Request&#41; object; `await request.json&#40;&#41;` returns the data that we posted from the event handler. We're returning a response with a [201 Created]&#40;https://http.dog/201&#41; status and the `id` of the newly generated todo in our database. Back in the event handler, we can use this to update the page: `svelte /// file: src/routes/+page.svelte <input type="text" autocomplete="off" onkeydown={async &#40;e&#41; => { if &#40;e.key !== 'Enter'&#41; return; const input = e.currentTarget; const description = input.value; const response = await fetch&#40;'/todo', { method: 'POST', body: JSON.stringify&#40;{ description }&#41;, headers: { 'Content-Type': 'application/json' } }&#41;; const { id } = await response.json&#40;&#41;; const todos = [...data.todos, { id, description }]; data = { ...data, todos }; input.value = ''; }} /> `)

[//]: # ()
[//]: # (## tutorial/03-sveltekit/07-api-routes/03-other-handlers/index.md)

[//]: # ()
[//]: # (--- title: Other handlers --- Similarly, we can add handlers for other HTTP verbs. Add a `/todo/[id]` route by creating a `src/routes/todo/[id]/+server.js` file with `PUT` and `DELETE` handlers for toggling and removing todos, using the `toggleTodo` and `deleteTodo` functions in `src/lib/server/database.js`: `js /// file: src/routes/todo/[id]/+server.js import * as database from '$lib/server/database.js'; export async function PUT&#40;{ params, request, cookies }&#41; { const { done } = await request.json&#40;&#41;; const userid = cookies.get&#40;'userid'&#41;; await database.toggleTodo&#40;{ userid, id: params.id, done }&#41;; return new Response&#40;null, { status: 204 }&#41;; } export async function DELETE&#40;{ params, cookies }&#41; { const userid = cookies.get&#40;'userid'&#41;; await database.deleteTodo&#40;{ userid, id: params.id }&#41;; return new Response&#40;null, { status: 204 }&#41;; } ` Since we don't need to return any actual data to the browser, we're returning an empty [Response]&#40;https://developer.mozilla.org/en-US/docs/Web/API/Response&#41; with a [204 No Content]&#40;https://http.dog/204&#41; status. We can now interact with this endpoint inside our event handlers: ``svelte /// file: src/routes/+page.svelte <label> <input type="checkbox" checked={todo.done} onchange={async &#40;e&#41; => { const done = e.currentTarget.checked; await fetch&#40;`/todo/${todo.id}`, { method: 'PUT', body: JSON.stringify&#40;{ done }&#41;, headers: { 'Content-Type': 'application/json' } }&#41;; }} /> <span>{todo.description}</span> <button aria-label="Mark as complete" onclick={async &#40;e&#41; => { await fetch&#40;`/todo/${todo.id}`, { method: 'DELETE' }&#41;; const todos = data.todos.filter&#40;&#40;t&#41; => t !== todo&#41;; data = { ...data, todos }; }} ></button> </label> ``)

[//]: # ()
[//]: # (## tutorial/03-sveltekit/08-app-state/index.md)

[//]: # ()
[//]: # (--- title: $app/state ---)

[//]: # ()
[//]: # (## tutorial/03-sveltekit/08-app-state/01-page-state/index.md)

[//]: # ()
[//]: # (--- title: page --- SvelteKit makes three readonly state objects available via the `$app/state` module — `page`, `navigating` and `updated`. The one you'll use most often is [`page`]&#40;/docs/kit/@sveltejs-kit#Page&#41;, which provides information about the current page: - `url` — the [URL]&#40;https://developer.mozilla.org/en-US/docs/Web/API/URL&#41; of the current page - `params` — the current page's [parameters]&#40;params&#41; - `route` — an object with an `id` property representing the current route - `status` — the HTTP status code of the current page - `error` — the error object of the current page, if any &#40;you'll learn more about error handling in [later]&#40;error-basics&#41; [exercises]&#40;handleerror&#41;&#41; - `data` — the data for the current page, combining the return values of all `load` functions - `form` — the data returned from a [form action]&#40;the-form-element&#41; Each of these properties is reactive, using `$state.raw` under the hood. Here's an example using `page.url.pathname`: `svelte /// file: src/routes/+layout.svelte <script> import { page } from '$app/state'; let { children } = $props&#40;&#41;; </script> <nav> <a href="/"aria-current={page.url.pathname === '/'}> home </a> <a href="/about"aria-current={page.url.pathname === '/about'}> about </a> </nav> {@render children&#40;&#41;} `)

[//]: # ()
[//]: # (## tutorial/03-sveltekit/08-app-state/02-navigating-state/index.md)

[//]: # ()
[//]: # (--- title: navigating --- The `navigating` object represents the current navigation. When a navigation starts — because of a link click, or a back/forward navigation, or a programmatic `goto` — the value of `navigating` will become an object with the following properties: - `from` and `to` — objects with `params`, `route` and `url` properties - `type` — the type of navigation, e.g. `link`, `popstate` or `goto` It can be used to show a loading indicator for long-running navigations. In this exercise, `src/routes/+page.server.js` and `src/routes/about/+page.server.js` both have an artificial delay. Inside `src/routes/+layout.svelte`, import the `navigating` object and add a message to the nav bar: `svelte /// file: src/routes/+layout.svelte <script> import { page,navigating} from '$app/state'; let { children } = $props&#40;&#41;; </script> <nav> <a href="/" aria-current={page.url.pathname === '/'}> home </a> <a href="/about" aria-current={page.url.pathname === '/about'}> about </a> {#if navigating.to} navigating to {navigating.to.url.pathname} {/if} </nav> {@render children&#40;&#41;} `)

[//]: # ()
[//]: # (## tutorial/03-sveltekit/08-app-state/03-updated-state/index.md)

[//]: # ()
[//]: # (--- title: updated --- The `updated` state contains `true` or `false` depending on whether a new version of the app has been deployed since the page was first opened. For this to work, your `svelte.config.js` must specify `kit.version.pollInterval`. `svelte /// file: src/routes/+layout.svelte <script> import { page, navigating,updated} from '$app/state'; </script> ` Version changes only happen in production, not during development. For that reason, `updated.current` will always be `false` in this tutorial. You can manually check for new versions, regardless of `pollInterval`, by calling `updated.check&#40;&#41;`. `svelte /// file: src/routes/+layout.svelte {#if updated.current} <div class="toast"> <p> A new version of the app is available <button onclick={&#40;&#41; => location.reload&#40;&#41;}> reload the page </button> </p> </div> {/if} `)

[//]: # ()
[//]: # (## tutorial/03-sveltekit/09-errors-and-redirects/index.md)

[//]: # ()
[//]: # (--- title: Errors and redirects ---)

[//]: # ()
[//]: # (## tutorial/03-sveltekit/09-errors-and-redirects/01-error-basics/index.md)

[//]: # ()
[//]: # (--- title: Basics --- There are two types of errors in SvelteKit — _expected_ errors and _unexpected_ errors. An expected error is one that was thrown via the [`error`]&#40;/docs/kit/@sveltejs-kit#error&#41; helper from `@sveltejs/kit`, as in `src/routes/expected/+page.server.js`: `js /// file: src/routes/expected/+page.server.js import { error } from '@sveltejs/kit'; export function load&#40;&#41; { error&#40;420, 'Enhance your calm'&#41;; } ` Any other error — such as the one in `src/routes/unexpected/+page.server.js` — is treated as unexpected: `js /// file: src/routes/unexpected/+page.server.js export function load&#40;&#41; { throw new Error&#40;'Kaboom!'&#41;; } ` When you throw an expected error, you're telling SvelteKit 'don't worry, I know what I'm doing here'. An unexpected error, by contrast, is assumed to be a bug in your app. When an unexpected error is thrown, its message and stack trace will be logged to the console. If you click the links in this app, you'll notice an important difference: the expected error message is shown to the user, whereas the unexpected error message is redacted and replaced with a generic 'Internal Error' message and a 500 status code. That's because error messages can contain sensitive data.)

[//]: # ()
[//]: # (## tutorial/03-sveltekit/09-errors-and-redirects/02-error-pages/index.md)

[//]: # ()
[//]: # (--- title: Error pages --- When something goes wrong inside a `load` function, SvelteKit renders an error page. The default error page is somewhat bland. We can customize it by creating a `src/routes/+error.svelte` component: `svelte /// file: src/routes/+error.svelte <script> import { page } from '$app/state'; import { emojis } from './emojis.js'; </script> <h1>{page.status} {page.error.message}</h1> <span style="font-size: 10em"> {emojis[page.status] ?? emojis[500]} </span> ` Notice that the `+error.svelte` component is rendered inside the root `+layout.svelte`. We can create more granular `+error.svelte` boundaries: `svelte /// file: src/routes/expected/+error.svelte <h1>this error was expected</h1> ` This component will be rendered for `/expected`, while the root `src/routes/+error.svelte` page will be rendered for any other errors that occur.)

[//]: # ()
[//]: # (## tutorial/03-sveltekit/09-errors-and-redirects/03-fallback-errors/index.md)

[//]: # ()
[//]: # (--- title: Fallback errors --- If things go _really_ wrong — an error occurs while loading the root layout data, or while rendering the error page — SvelteKit will fall back to a static error page. Add a new `src/routes/+layout.server.js` file to see this in action: `js /// file: src/routes/+layout.server.js export function load&#40;&#41; { throw new Error&#40;'yikes'&#41;; } ` You can customise the fallback error page. Create a `src/error.html` file: `html /// file: src/error.html <h1>Game over</h1> <p>Code %sveltekit.status%</p> <p>%sveltekit.error.message%</p> ` This file can include the following: - `%sveltekit.status%` — the HTTP status code - `%sveltekit.error.message%` — the error message)

[//]: # ()
[//]: # (## tutorial/03-sveltekit/09-errors-and-redirects/04-redirects/index.md)

[//]: # ()
[//]: # (--- title: Redirects --- We can use the `redirect` mechanism to redirect from one page to another. Create a new `load` function in `src/routes/a/+page.server.js`: `js /// file: src/routes/a/+page.server.js import { redirect } from '@sveltejs/kit'; export function load&#40;&#41; { redirect&#40;307, '/b'&#41;; } ` Navigating to `/a` will now take us straight to `/b`. You can `redirect&#40;...&#41;` inside `load` functions, form actions, API routes and the `handle` hook, which we'll discuss in a later chapter. The most common status codes you'll use: - `303` — for form actions, following a successful submission - `307` — for temporary redirects - `308` — for permanent redirects)

[//]: # ()
[//]: # (## tutorial/03-sveltekit/09-errors-and-redirects/xx-custom-error-messages/index.md)

[//]: # ()
[//]: # (--- title: Customizing the error message --- The error page in the previous exercise is rather static. Maybe you want to show the error message so you can help people turning up in your support channels faster. For this, SvelteKit provides you with `page.error` and `page.status`, which contain information about the error and the status code. Let's add it to `+error.svelte`: `svelte /// file: src/routes/+error.svelte <script> import { page } from '$app/state'; let online = typeof navigator !== 'undefined' ? navigator.onLine : true; </script> {#if page.status === 404} <h1>Not found</h1> {:elseif !online} <h1>You're offline</h1> {:else} <h1>Oops!</h1> <p>Something went wrong</p> <p>{page.error.message}</p> {/if} ` That's better, but `page.error.message` always contains "Internal Error" - how so? This is because SvelteKit plays it safe and prevents you from accidentally showing sensitive information as part of the error message. To customize it, implement the `handleError` hook in `hooks.server.js` and `hooks.client.js` which run when an unexpected error is thrown during data loads on the server or client respectively. `js // hooks.server.js export function handleError&#40;{ error }&#41; { return { message: 'Internal Error' }; // the default implementation of this hook return { message: error instanceof Error ? error.message : 'Internal Error' }; } ` `js // hooks.client.js export function handleError&#40;{ error }&#41; { return { message: 'Internal Error' }; // the default implementation of this hook return { message: error instanceof Error ? error.message : 'Internal Error' }; } ` You could also call your error reporting service in these hooks. Note that you can return more than an error message if you like. Whatever object shape you return will be available in `page.error`, the only requirement is a `message` property. You can read more about this &#40;and how to make it type-safe!&#41; in the [error docs]&#40;/docs/kit/errors&#41;.)

[//]: # ()
[//]: # (## tutorial/04-advanced-sveltekit/index.md)

[//]: # ()
[//]: # (--- title: Advanced SvelteKit label: Part 4 scope: { 'prefix': '/', 'name': 'project' } focus: /src/routes/+page.svelte ---)

[//]: # ()
[//]: # (## tutorial/04-advanced-sveltekit/01-hooks/index.md)

[//]: # ()
[//]: # (--- title: Hooks ---)

[//]: # ()
[//]: # (## tutorial/04-advanced-sveltekit/01-hooks/01-handle/index.md)

[//]: # ()
[//]: # (--- title: handle --- SvelteKit provides several _hooks_ — ways to intercept and override the framework's default behaviour. The most elementary hook is `handle`, which lives in `src/hooks.server.js`. It receives an `event` object along with a `resolve` function, and returns a [`Response`]&#40;https://developer.mozilla.org/en-US/docs/Web/API/Response&#41;. `resolve` is where the magic happens: SvelteKit matches the incoming request URL to a route of your app, imports the relevant code &#40;`+page.server.js` and `+page.svelte` files and so on&#41;, loads the data needed by the route, and generates the response. The default `handle` hook looks like this: `js /// file: src/hooks.server.js export async function handle&#40;{ event, resolve }&#41; { return await resolve&#40;event&#41;; } ` For pages &#40;as opposed to [API routes]&#40;get-handlers&#41;&#41;, you can modify the generated HTML with `transformPageChunk`: `js /// file: src/hooks.server.js export async function handle&#40;{ event, resolve }&#41; { return await resolve&#40;event, { transformPageChunk: &#40;{ html }&#41; => html.replace&#40; '<body', '<body style="color: hotpink"' &#41; }&#41;; } ` You can also create entirely new routes: `js /// file: src/hooks.server.js export async function handle&#40;{ event, resolve }&#41; { if &#40;event.url.pathname === '/ping'&#41; { return new Response&#40;'pong'&#41;; } return await resolve&#40;event, { transformPageChunk: &#40;{ html }&#41; => html.replace&#40; '<body', '<body style="color: hotpink"' &#41; }&#41;; } `)

[//]: # ()
[//]: # (## tutorial/04-advanced-sveltekit/01-hooks/02-event/index.md)

[//]: # ()
[//]: # (--- title: The RequestEvent object --- The `event` object passed into `handle` is the same object — an instance of a [`RequestEvent`]&#40;/docs/kit/@sveltejs-kit#RequestEvent&#41; — that is passed into [API routes]&#40;get-handlers&#41; in `+server.js` files, [form actions]&#40;the-form-element&#41; in `+page.server.js` files, and `load` functions in `+page.server.js` and `+layout.server.js`. It contains a number of useful properties and methods, some of which we've already encountered: - `cookies` — the [cookies API]&#40;cookies&#41; - `fetch` — the standard [Fetch API]&#40;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&#41;, with additional powers - `getClientAddress&#40;&#41;` — a function to get the client's IP address - `isDataRequest` — `true` if the browser is requesting data for a page during client-side navigation, `false` if a page/route is being requested directly - `locals` — a place to put arbitrary data - `params` — the route parameters - `request` — the [Request]&#40;https://developer.mozilla.org/en-US/docs/Web/API/Request&#41; object - `route` — an object with an `id` property representing the route that was matched - `setHeaders&#40;...&#41;` — a function for [setting HTTP headers]&#40;headers&#41; on the response - `url` — a [URL]&#40;https://developer.mozilla.org/en-US/docs/Web/API/URL&#41; object representing the current request A useful pattern is to add some data to `event.locals` in `handle` so that it can be read in subsequent `load` functions: `js /// file: src/hooks.server.js export async function handle&#40;{ event, resolve }&#41; { event.locals.answer = 42; return await resolve&#40;event&#41;; } ` ``js /// file: src/routes/+page.server.js export function load&#40;event&#41; { return { message: `the answer is ${event.locals.answer}` }; } ``)

[//]: # ()
[//]: # (## tutorial/04-advanced-sveltekit/01-hooks/03-handlefetch/index.md)

[//]: # ()
[//]: # (--- title: handleFetch --- The `event` object has a `fetch` method that behaves like the standard [Fetch API]&#40;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&#41;, but with superpowers: - it can be used to make credentialed requests on the server, as it inherits the `cookie` and `authorization` headers from the incoming request - it can make relative requests on the server &#40;ordinarily, `fetch` requires a URL with an origin when used in a server context&#41; - internal requests &#40;e.g. for `+server.js` routes&#41; go directly to the handler function when running on the server, without the overhead of an HTTP call Its behaviour can be modified with the `handleFetch` hook, which by default looks like this: `js /// file: src/hooks.server.js export async function handleFetch&#40;{ event, request, fetch }&#41; { return await fetch&#40;request&#41;; } ` For example, we could respond to requests for `src/routes/a/+server.js` with responses from `src/routes/b/+server.js` instead: `js /// file: src/hooks.server.js export async function handleFetch&#40;{ event, request, fetch }&#41; { const url = new URL&#40;request.url&#41;; if &#40;url.pathname === '/a'&#41; { return await fetch&#40;'/b'&#41;; } return await fetch&#40;request&#41;; } ` Later, when we cover [universal `load` functions]&#40;universal-load-functions&#41;, we'll see that `event.fetch` can also be called from the browser. In that scenario, `handleFetch` is useful if you have requests to a public URL like `https://api.yourapp.com` from the browser, that should be redirected to an internal URL &#40;bypassing whatever proxies and load balancers sit between the API server and the public internet&#41; when running on the server.)

[//]: # ()
[//]: # (## tutorial/04-advanced-sveltekit/01-hooks/04-handleerror/index.md)

[//]: # ()
[//]: # (--- title: handleError --- The `handleError` hook lets you intercept unexpected errors and trigger some behaviour, like pinging a Slack channel or sending data to an error logging service. As you'll recall from an [earlier exercise]&#40;error-basics&#41;, an error is _unexpected_ if it wasn't created with the `error` helper from `@sveltejs/kit`. It generally means something in your app needs fixing. The default behaviour is to log the error: `js /// file: src/hooks.server.js export function handleError&#40;{ event, error }&#41; { console.error&#40;error.stack&#41;; } ` If you navigate to `/the-bad-place`, you'll see this in action — the error page is shown, and if you open the terminal &#40;using the button to the right of the URL bar&#41;, you'll see the message from `src/routes/the-bad-place/+page.server.js`. Notice that we're _not_ showing the error message to the user. That's because error messages can include sensitive information that at best will confuse your users, and at worst could benefit evildoers. Instead, the error object available to your application — represented as `page.error` in your `+error.svelte` pages, or `%sveltekit.error%` in your `src/error.html` fallback — is just this: `js { message: 'Internal Error' // or 'Not Found' for a 404 } ` In some situations you may want to customise this object. To do so, you can return an object from `handleError`: `js /// file: src/hooks.server.js export function handleError&#40;{ event, error }&#41; { console.error&#40;error.stack&#41;; return { message: 'everything is fine', code: 'JEREMYBEARIMY' }; } ` You can now reference properties other than `message` in a custom error page. Create `src/routes/+error.svelte`: `svelte /// file: src/routes/+error.svelte <script> import { page } from '$app/state'; </script> <h1>{page.status}</h1> <p>{page.error.message}</p> <p>error code: {page.error.code}</p> `)

[//]: # ()
[//]: # (## tutorial/04-advanced-sveltekit/02-page-options/index.md)

[//]: # ()
[//]: # (--- title: Page options ---)

[//]: # ()
[//]: # (## tutorial/04-advanced-sveltekit/02-page-options/01-page-options/index.md)

[//]: # ()
[//]: # (--- title: Basics --- In the chapter on [loading data]&#40;/tutorial/kit/page-data&#41;, we saw how you can export `load` functions from `+page.js`, `+page.server.js`, `+layout.js` and `+layout.server.js` files. We can also export various **page options** from these modules: - `ssr` — whether or not pages should be server-rendered - `csr` — whether to load the SvelteKit client - `prerender` — whether to prerender pages at build time, instead of per-request - `trailingSlash` — whether to strip, add, or ignore trailing slashes in URLs In the following exercises, we'll learn about each of these in turn. Page options can apply to individual pages &#40;if exported from `+page.js` or `+page.server.js`&#41;, or groups of pages &#40;if exported from `+layout.js` or `+layout.server.js`&#41;. To define an option for the whole app, export it from the root layout. Child layouts and pages override values set in parent layouts, so — for example — you can enable prerendering for your entire app then disable it for pages that need to be dynamically rendered. You can mix and match these options in different areas of your app — you could prerender your marketing pages, dynamically server-render your data-driven pages, and treat your admin pages as a client-rendered SPA. This makes SvelteKit very versatile.)

[//]: # ()
[//]: # (## tutorial/04-advanced-sveltekit/02-page-options/02-ssr/index.md)

[//]: # ()
[//]: # (--- title: ssr --- Server-side rendering &#40;SSR&#41; is the process of generating HTML on the server, and is what SvelteKit does by default. It's important for performance and [resilience]&#40;https://kryogenix.org/code/browser/everyonehasjs.html&#41;, and is very beneficial for search engine optimization &#40;SEO&#41; — while some search engines can index content that is rendered in the browser with JavaScript, it happens less frequently and reliably. That said, some components _can't_ be rendered on the server, perhaps because they expect to be able to access browser globals like `window` immediately. If you can, you should change those components so that they _can_ render on the server, but if you can't then you can disable SSR: `js /// file: src/routes/+page.server.js export const ssr = false; `)

[//]: # ()
[//]: # (## tutorial/04-advanced-sveltekit/02-page-options/03-csr/index.md)

[//]: # ()
[//]: # (--- title: csr --- Client-side rendering is what makes the page interactive — such as incrementing the counter when you click the button in this app — and enables SvelteKit to update the page upon navigation without a full-page reload. As with `ssr`, you can disable client-side rendering altogether: `js /// file: src/routes/+page.server.js export const csr = false; ` This means that no JavaScript is served to the client, but it also means that your components are no longer interactive. It can be a useful way to check whether or not your application is usable for people who — for whatever reason — cannot use JavaScript.)

[//]: # ()
[//]: # (## tutorial/04-advanced-sveltekit/02-page-options/04-prerender/index.md)

[//]: # ()
[//]: # (--- title: prerender --- Prerendering means generating HTML for a page once, at build time, rather than dynamically for each request. The advantage is that serving static data is extremely cheap and performant, allowing you to easily serve large numbers of users without worrying about cache-control headers &#40;which are easy to get wrong&#41;. The tradeoff is that the build process takes longer, and prerendered content can only be updated by building and deploying a new version of the application. To prerender a page, set `prerender` to `true`: `js /// file: src/routes/+page.server.js export const prerender = true; ` Here in the tutorial, this won't have any observable effect, since the application is running in `dev` mode. Not all pages can be prerendered. The basic rule is this: for content to be prerenderable, any two users hitting it directly must get the same content from the server, and the page must not contain form actions. Pages with dynamic route parameters can be prerendered as long as they are specified in the [`prerender.entries`]&#40;/docs/kit/configuration#prerender&#41; configuration or can be reached by following links from pages that _are_ in `prerender.entries`.)

[//]: # ()
[//]: # (## tutorial/04-advanced-sveltekit/02-page-options/05-trailingslash/index.md)

[//]: # ()
[//]: # (--- title: trailingSlash --- Two URLs like `/foo` and `/foo/` might look the same, but they're actually different. A relative URL like `./bar` will resolve to `/bar` in the first case and `/foo/bar` in the second, and search engines will treat them as separate entries, harming your SEO. In short, being loosey-goosey about trailing slashes is a bad idea. By default, SvelteKit strips trailing slashes, meaning that a request for `/foo/` will result in a redirect to `/foo`. If you instead want to ensure that a trailing slash is always present, you can specify the `trailingSlash` option accordingly: `js /// file: src/routes/always/+page.server.js export const trailingSlash = 'always'; ` To accommodate both cases &#40;this is not recommended!&#41;, use `'ignore'`: `js /// file: src/routes/ignore/+page.server.js export const trailingSlash = 'ignore'; ` The default value is `'never'`. Whether or not trailing slashes are applied affects prerendering. A URL like `/always/` will be saved to disk as `always/index.html` whereas a URL like `/never` will be saved as `never.html`.)

[//]: # ()
[//]: # (## tutorial/04-advanced-sveltekit/03-link-options/index.md)

[//]: # ()
[//]: # (--- title: Link options ---)

[//]: # ()
[//]: # (## tutorial/04-advanced-sveltekit/03-link-options/01-preload/index.md)

[//]: # ()
[//]: # (--- title: Preloading --- In this exercise, the `/slow-a` and `/slow-b` routes both have artificial delays in their `load` functions, meaning it takes a long time to navigate to them. You can't always make your data load more quickly — sometimes it's out of your control — but SvelteKit can speed up navigations by _anticipating_ them. When an `<a>` element has a `data-sveltekit-preload-data` attribute, SvelteKit will begin the navigation as soon as the user hovers over the link &#40;on desktop&#41; or taps it &#40;on mobile&#41;. Try adding it to the first link: `svelte /// file: src/routes/+layout.svelte <nav> <a href="/">home</a> <a href="/slow-a"data-sveltekit-preload-data>slow-a</a> <a href="/slow-b">slow-b</a> </nav> ` Navigating to `/slow-a` will now be noticeably faster. Starting navigation on hover or tap &#40;rather than waiting for a `click` event to be registered&#41; might not sound like it makes much difference, but in practice it typically saves 200ms or more. That's enough to be the difference between sluggish and snappy. You can put the attribute on individual links, or on any element that _contains_ links. The default project template includes the attribute on the `<body>` element: `html <body data-sveltekit-preload-data> %sveltekit.body% </body> ` You can customise the behaviour further by specifying one of the following values for the attribute: - `"hover"` &#40;default, falls back to `"tap"` on mobile&#41; - `"tap"` — only begin preloading on tap - `"off"` — disable preloading Using `data-sveltekit-preload-data` may sometimes result in false positives - i.e. loading data in anticipation of a navigation that doesn't then happen — which might be undesirable. As an alternative, `data-sveltekit-preload-code` allows you to preload the JavaScript needed by a given route without eagerly loading its data. This attribute can have the following values: - `"eager"` — preload everything on the page following a navigation - `"viewport"` — preload everything as it appears in the viewport - `"hover"` &#40;default&#41; as above - `"tap"` — as above - `"off"` — as above You can also initiate preloading programmatically with `preloadCode` and `preloadData` imported from `$app/navigation`: `js import { preloadCode, preloadData } from '$app/navigation'; // preload the code and data needed to navigate to /foo preloadData&#40;'/foo'&#41;; // preload the code needed to navigate to /bar, but not the data preloadCode&#40;'/bar'&#41;; `)

[//]: # ()
[//]: # (## tutorial/04-advanced-sveltekit/03-link-options/02-reload/index.md)

[//]: # ()
[//]: # (--- title: Reloading the page --- Ordinarily, SvelteKit will navigate between pages without refreshing the page. In this exercise, if we navigate between `/` and `/about`, the timer keeps on ticking. In rare cases, you might want to disable this behaviour. You can do so by adding the `data-sveltekit-reload` attribute on an individual link, or any element that contains links: `svelte /// file: src/routes/+layout.svelte <navdata-sveltekit-reload> <a href="/">home</a> <a href="/about">about</a> </nav> ` For more information on available link options and their values, consult the [link options documentation]&#40;/docs/kit/link-options&#41;.)

[//]: # ()
[//]: # (## tutorial/04-advanced-sveltekit/04-advanced-routing/index.md)

[//]: # ()
[//]: # (--- title: Advanced routing ---)

[//]: # ()
[//]: # (## tutorial/04-advanced-sveltekit/04-advanced-routing/01-optional-params/index.md)

[//]: # ()
[//]: # (--- title: Optional parameters --- In the first chapter on [routing]&#40;/tutorial/kit/pages&#41;, we learned how to create routes with [dynamic parameters]&#40;/tutorial/kit/params&#41;. Sometimes it's helpful to make a parameter optional. A classic example is when you use the pathname to determine the locale — `/fr/...`, `/de/...` and so on — but you also want to have a default locale. To do that, we use double brackets. Rename the `[lang]` directory to `[[lang]]`. The app now fails to build, because `src/routes/+page.svelte` and `src/routes/[[lang]]/+page.svelte` would both match `/`. Delete `src/routes/+page.svelte`. &#40;You may need to reload the app to recover from the error page&#41;. Lastly, edit `src/routes/[[lang]]/+page.server.js` to specify the default locale: `js /// file: src/routes/[[lang]]/+page.server.js const greetings = { en: 'hello!', de: 'hallo!', fr: 'bonjour!' }; export function load&#40;{ params }&#41; { return { greeting: greetings[params.lang?? 'en'] }; } `)

[//]: # ()
[//]: # (## tutorial/04-advanced-sveltekit/04-advanced-routing/02-rest-params/index.md)

[//]: # ()
[//]: # (--- title: Rest parameters path: /how focus: /src/routes/[path]/+page.svelte --- To match an unknown number of path segments, use a `[...rest]` parameter, so named for its resemblance to [rest parameters in JavaScript]&#40;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters&#41;. Rename `src/routes/[path]` to `src/routes/[...path]`. The route now matches any path. > > `tree > src/routes/ > ├ categories/ > │ ├ animal/ > │ ├ mineral/ > │ ├ vegetable/ > +++│ ├ [...catchall]/ > │ │ ├ +error.svelte > │ │ └ +page.server.js+++ > ` > > Inside the `+page.server.js` file, `error&#40;404&#41;` inside `load`. Rest parameters do _not_ need to go at the end — a route like `/items/[...path]/edit` or `/items/[...path].json` is totally valid.)

[//]: # ()
[//]: # (## tutorial/04-advanced-sveltekit/04-advanced-routing/03-param-matchers/index.md)

[//]: # ()
[//]: # (--- title: Param matchers path: /colors/ff3e00 --- To prevent the router from matching on invalid input, you can specify a _matcher_. For example, you might want a route like `/colors/[value]` to match hex values like `/colors/ff3e00` but not named colors like `/colors/octarine` or any other arbitrary input. First, create a new file called `src/params/hex.js` and export a `match` function from it: `js /// file: src/params/hex.js export function match&#40;value&#41; { return /^[0-9a-f]{6}$/.test&#40;value&#41;; } ` Then, to use the new matcher, rename `src/routes/colors/[color]` to `src/routes/colors/[color=hex]`. Now, whenever someone navigates to that route, SvelteKit will verify that `color` is a valid `hex` value. If not, SvelteKit will try to match other routes, before eventually returning a 404.)

[//]: # ()
[//]: # (## tutorial/04-advanced-sveltekit/04-advanced-routing/04-route-groups/index.md)

[//]: # ()
[//]: # (--- title: Route groups --- As we saw in the [routing introduction]&#40;/tutorial/kit/layouts&#41;, layouts are a way to share UI and data loading logic between different routes. Sometimes it's useful to use layouts without affecting the route — for example, you might need your `/app` and `/account` routes to be behind authentication, while your `/about` page is open to the world. We can do this with a _route group_, which is a directory in parentheses. Create an `&#40;authed&#41;` group by renaming `account` to `&#40;authed&#41;/account` then renaming `app` to `&#40;authed&#41;/app`. Now we can control access to these routes by creating `src/routes/&#40;authed&#41;/+layout.server.js`: ``js /// file: src/routes/&#40;authed&#41;/+layout.server.js import { redirect } from '@sveltejs/kit'; export function load&#40;{ cookies, url }&#41; { if &#40;!cookies.get&#40;'logged_in'&#41;&#41; { redirect&#40;303, `/login?redirectTo=${url.pathname}`&#41;; } } `` If you try to visit these pages, you'll be redirected to the `/login` route, which has a form action in `src/routes/login/+page.server.js` that sets the `logged_in` cookie. We can also add some UI to these two routes by adding a `src/routes/&#40;authed&#41;/+layout.svelte` file: `svelte /// file: src/routes/&#40;authed&#41;/+layout.svelte <script> let { children } = $props&#40;&#41;; </script> {@render children&#40;&#41;} <form method="POST" action="/logout"> <button>log out</button> </form> `)

[//]: # ()
[//]: # (## tutorial/04-advanced-sveltekit/04-advanced-routing/05-breaking-out-of-layouts/index.md)

[//]: # ()
[//]: # (--- title: Breaking out of layouts editing_constraints: { 'create': ['/src/routes/a/b/c/+page@b.svelte', '/src/routes/a/b/c/+page@a.svelte'] } --- Ordinarily, a page inherits every layout above it, meaning that `src/routes/a/b/c/+page.svelte` inherits four layouts: - `src/routes/+layout.svelte` - `src/routes/a/+layout.svelte` - `src/routes/a/b/+layout.svelte` - `src/routes/a/b/c/+layout.svelte` Occasionally, it's useful to break out of the current layout hierarchy. We can do that by adding the `@` sign followed by the name of the parent segment to 'reset' to — for example `+page@b.svelte` would put `/a/b/c` inside `src/routes/a/b/+layout.svelte`, while `+page@a.svelte` would put it inside `src/routes/a/+layout.svelte`. Let's reset it all the way to the root layout, by renaming it to `+page@.svelte`.)

[//]: # ()
[//]: # (## tutorial/04-advanced-sveltekit/05-advanced-loading/index.md)

[//]: # ()
[//]: # (--- title: Advanced loading ---)

[//]: # ()
[//]: # (## tutorial/04-advanced-sveltekit/05-advanced-loading/01-universal-load-functions/index.md)

[//]: # ()
[//]: # (--- title: Universal load functions --- In the [previous section on loading]&#40;page-data&#41; we loaded data from the server using `+page.server.js` and `+layout.server.js` files. This is very convenient if you need to do things like getting data directly from a database, or reading cookies. Sometimes it doesn't make sense to load data from the server when doing a client-side navigation. For example: - You're loading data from an external API - You want to use in-memory data if it's available - You want to delay navigation until an image has been preloaded, to avoid pop-in - You need to return something from `load` that can't be serialized &#40;SvelteKit uses [devalue]&#40;https://github.com/Rich-Harris/devalue&#41; to turn server data into JSON&#41;, such as a component or a store In this exercise, we're dealing with the latter case. The server `load` functions in `src/routes/red/+page.server.js`, `src/routes/green/+page.server.js` and `src/routes/blue/+page.server.js` return a `component` constructor, which can't be serialized like data. If you navigate to `/red`, `/green` or `/blue`, you'll see a 'Data returned from `load` ... is not serializable' error in the terminal. To turn the server `load` functions into universal `load` functions, rename each `+page.server.js` file to `+page.js`. Now, the functions will run on the server during server-side rendering, but will also run in the browser when the app hydrates or the user performs a client-side navigation. We can now use the `component` returned from these `load` functions like any other value, including in `src/routes/+layout.svelte`: `svelte /// file: src/routes/+layout.svelte <nav class={[page.data.color && 'has-color']} style:background={page.data.color ?? 'var&#40;--bg-2&#41;'} > <a href="/">home</a> <a href="/red">red</a> <a href="/green">green</a> <a href="/blue">blue</a> {#if page.data.component} <page.data.component /> {/if} </nav> ` Read the [documentation]&#40;/docs/kit/load#Universal-vs-server&#41; to learn more about the distinction between server `load` functions and universal `load` functions, and when to use which.)

[//]: # ()
[//]: # (## tutorial/04-advanced-sveltekit/05-advanced-loading/02-using-both-load-functions/index.md)

[//]: # ()
[//]: # (--- title: Using both load functions --- Occasionally, you might need to use a server load function and a universal load function together. For example, you might need to return data from the server, but also return a value that can't be serialized as server data. In this example we want to return a different component from `load` depending on whether the data we got from `src/routes/+page.server.js` is `cool` or not. We can access server data in `src/routes/+page.js` via the `data` property: `js /// file: src/routes/+page.js export async function load&#40;{ data }&#41; { const module =data.cool ? await import&#40;'./CoolComponent.svelte'&#41; : await import&#40;'./BoringComponent.svelte'&#41;; return { component: module.default, message:data.message }; } `)

[//]: # ()
[//]: # (## tutorial/04-advanced-sveltekit/05-advanced-loading/03-await-parent/index.md)

[//]: # ()
[//]: # (--- title: Using parent data --- As we saw in the introduction to [layout data]&#40;/tutorial/kit/layout-data&#41;, `+page.svelte` and `+layout.svelte` components have access to everything returned from their parent `load` functions. Occasionally it's useful for the `load` functions themselves to access data from their parents. This can be done with `await parent&#40;&#41;`. To show how it works, we'll sum two numbers that come from different `load` functions. First, return some data from `src/routes/+layout.server.js`: `js /// file: src/routes/+layout.server.js export function load&#40;&#41; { return {a: 1}; } ` Then, get that data in `src/routes/sum/+layout.js`: `js /// file: src/routes/sum/+layout.js export async function load&#40;{ parent }&#41; { const { a } = await parent&#40;&#41;; return {b: a + 1}; } ` Finally, in `src/routes/sum/+page.js`, get parent data from both `load` functions: `js /// file: src/routes/sum/+page.js export async function load&#40;{ parent }&#41; { const { a, b } = await parent&#40;&#41;; return {c: a + b}; } `)

[//]: # ()
[//]: # (## tutorial/04-advanced-sveltekit/05-advanced-loading/04-invalidation/index.md)

[//]: # ()
[//]: # (--- title: Invalidation path: /Europe/London --- When the user navigates from one page to another, SvelteKit calls your `load` functions, but only if it thinks something has changed. In this example, navigating between timezones causes the `load` function in `src/routes/[...timezone]/+page.js` to re-run because `params.timezone` is invalid. But the `load` function in `src/routes/+layout.js` does _not_ re-run, because as far as SvelteKit is concerned it wasn't invalidated by the navigation. We can fix that by manually invalidating it using the [`invalidate&#40;...&#41;`]&#40;/docs/kit/$app-navigation#invalidate&#41; function, which takes a URL and re-runs any `load` functions that depend on it. Because the `load` function in `src/routes/+layout.js` calls `fetch&#40;'/api/now'&#41;`, it depends on `/api/now`. In `src/routes/[...timezone]/+page.svelte`, add an `onMount` callback that calls `invalidate&#40;'/api/now'&#41;` once a second: `svelte /// file: src/routes/[...timezone]/+page.svelte <script> import { onMount } from 'svelte'; import { invalidate } from '$app/navigation'; let { data } = $props&#40;&#41;; onMount&#40;&#40;&#41; => { const interval = setInterval&#40;&#40;&#41; => { invalidate&#40;'/api/now'&#41;; }, 1000&#41;; return &#40;&#41; => { clearInterval&#40;interval&#41;; }; }&#41;; </script> <h1> {new Intl.DateTimeFormat&#40;[], { timeStyle: 'full', timeZone: data.timezone }&#41;.format&#40;new Date&#40;data.now&#41;&#41;} </h1> `)

[//]: # ()
[//]: # (## tutorial/04-advanced-sveltekit/05-advanced-loading/05-custom-dependencies/index.md)

[//]: # ()
[//]: # (--- title: Custom dependencies path: /Europe/London --- Calling `fetch&#40;url&#41;` inside a `load` function registers `url` as a dependency. Sometimes it's not appropriate to use `fetch`, in which case you can specify a dependency manually with the [`depends&#40;url&#41;`]&#40;/docs/kit/load#Rerunning-load-functions-Manual-invalidation&#41; function. Since any string that begins with an `[a-z]+:` pattern is a valid URL, we can create custom invalidation keys like `data:now`. Update `src/routes/+layout.js` to return a value directly rather than making a `fetch` call, and add the `depends`: `js /// file: src/routes/+layout.js export async function load&#40;{depends}&#41; { depends&#40;'data:now'&#41;; return { now:Date.now&#40;&#41; }; } ` Now, update the `invalidate` call in `src/routes/[...timezone]/+page.svelte`: `svelte /// file: src/routes/[...timezone]/+page.svelte <script> import { onMount } from 'svelte'; import { invalidate } from '$app/navigation'; let { data } = $props&#40;&#41;; onMount&#40;&#40;&#41; => { const interval = setInterval&#40;&#40;&#41; => { invalidate&#40;'data:now'&#41;; }, 1000&#41;; return &#40;&#41; => { clearInterval&#40;interval&#41;; }; }&#41;; </script> `)

[//]: # ()
[//]: # (## tutorial/04-advanced-sveltekit/05-advanced-loading/06-invalidate-all/index.md)

[//]: # ()
[//]: # (--- title: invalidateAll path: /Europe/London --- Finally, there's the nuclear option — `invalidateAll&#40;&#41;`. This will indiscriminately re-run all `load` functions for the current page, regardless of what they depend on. Update `src/routes/[...timezone]/+page.svelte` from the previous exercise: `svelte /// file: src/routes/[...timezone]/+page.svelte <script> import { onMount } from 'svelte'; import {invalidateAll} from '$app/navigation'; let { data } = $props&#40;&#41;; onMount&#40;&#40;&#41; => { const interval = setInterval&#40;&#40;&#41; => { invalidateAll&#40;&#41;; }, 1000&#41;; return &#40;&#41; => { clearInterval&#40;interval&#41;; }; }&#41;; </script> ` The `depends` call in `src/routes/+layout.js` is no longer necessary: `js /// file: src/routes/+layout.js export async function load&#40;{ depends }&#41; { depends&#40;'data:now'&#41;; return { now: Date.now&#40;&#41; }; } `)

[//]: # ()
[//]: # (## tutorial/04-advanced-sveltekit/06-environment-variables/index.md)

[//]: # ()
[//]: # (--- title: Environment variables ---)

[//]: # ()
[//]: # (## tutorial/04-advanced-sveltekit/06-environment-variables/01-env-static-private/index.md)

[//]: # ()
[//]: # (--- title: $env/static/private --- Environment variables — like API keys and database credentials — can be added to a `.env` file, and they will be made available to your application. > > Environment variables in `process.env` are also available via `$env/static/private`. In this exercise, we want to allow the user to enter the website if they know the correct passphrase, using an environment variable. First, in `.env`, add a new environment variable: ```env /// file: .env PASSPHRASE="open sesame" ``` Open `src/routes/+page.server.js`. Import `PASSPHRASE`from`$env/static/private` and use it inside the [form action]&#40;/tutorial/kit/the-form-element&#41;: ```js /// file: src/routes/+page.server.js import { redirect, fail } from '@sveltejs/kit'; import { PASSPHRASE } from '$env/static/private'; export function load&#40;{ cookies }&#41; { if &#40;cookies.get&#40;'allowed'&#41;&#41; { redirect&#40;307, '/welcome'&#41;; } } export const actions = { default: async &#40;{ request, cookies }&#41; => { const data = await request.formData&#40;&#41;; if &#40;data.get&#40;'passphrase'&#41; ===PASSPHRASE&#41; { cookies.set&#40;'allowed', 'true', { path: '/' }&#41;; redirect&#40;303, '/welcome'&#41;; } return fail&#40;403, { incorrect: true }&#41;; } }; ``The website is now accessible to anyone who knows the correct passphrase. ## Keeping secrets It's important that sensitive data doesn't accidentally end up being sent to the browser, where it could easily be stolen by hackers and scoundrels. SvelteKit makes it easy to prevent this from happening. Notice what happens if we try to import `PASSPHRASE` into `src/routes/+page.svelte`:``svelte /// file: src/routes/+page.svelte <script> import { PASSPHRASE } from '$env/static/private'; let { form } = $props&#40;&#41;; </script> ``` An error overlay pops up, telling us that `$env/static/private`cannot be imported into client-side code. It can only be imported into server modules: -`+page.server.js`-`+layout.server.js`-`+server.js`- any modules ending with`.server.js`- any modules inside`src/lib/server`In turn, these modules can only be imported by _other_ server modules. ## Static vs dynamic The`static`in`$env/static/private` indicates that these values are known at build time, and can be _statically replaced_. This enables useful optimisations: ```js import { FEATURE_FLAG_X } from '$env/static/private'; if &#40;FEATURE*FLAG_X === 'enabled'&#41; { // code in here will be removed from the build output // if FEATURE_FLAG_X is not enabled } ``` In some cases you might need to refer to environment variables that are \_dynamic* — in other words, not known until we run the app. We'll cover this case in the next exercise.)

[//]: # ()
[//]: # (## tutorial/04-advanced-sveltekit/06-environment-variables/02-env-dynamic-private/index.md)

[//]: # ()
[//]: # (--- title: $env/dynamic/private --- If you need to read the values of environment variables when the app runs, as opposed to when the app is built, you can use `$env/dynamic/private`instead of`$env/static/private`: ```js /// file: src/routes/+page.server.js import { redirect, fail } from '@sveltejs/kit'; import {env} from '$env/dynamic/private'; export function load&#40;{ cookies }&#41; { if &#40;cookies.get&#40;'allowed'&#41;&#41; { redirect&#40;307, '/welcome'&#41;; } } export const actions = { default: async &#40;{ request, cookies }&#41; => { const data = await request.formData&#40;&#41;; if &#40;data.get&#40;'passphrase'&#41; ===env.PASSPHRASE&#41; { cookies.set&#40;'allowed', 'true', { path: '/' }&#41;; redirect&#40;303, '/welcome'&#41;; } return fail&#40;403, { incorrect: true }&#41;; } }; ```)

[//]: # ()
[//]: # (## tutorial/04-advanced-sveltekit/06-environment-variables/03-env-static-public/index.md)

[//]: # ()
[//]: # (--- title: $env/static/public --- Some environment variables _can_ be safely exposed to the browser. These are distinguished from private environment variables with a `PUBLIC_` prefix. Add values to the two public environment variables in `.env`: ```env /// file: .env PUBLIC_THEME_BACKGROUND="steelblue" PUBLIC_THEME_FOREGROUND="bisque" ``` Then, import them into `src/routes/+page.svelte`: ```svelte /// file: src/routes/+page.svelte <script> const PUBLIC_THEME_BACKGROUND = 'white'; const PUBLIC_THEME_FOREGROUND = 'black'; import { PUBLIC_THEME_BACKGROUND, PUBLIC_THEME_FOREGROUND } from '$env/static/public'; </script> ```)

[//]: # ()
[//]: # (## tutorial/04-advanced-sveltekit/06-environment-variables/04-env-dynamic-public/index.md)

[//]: # ()
[//]: # (--- title: $env/dynamic/public --- As with [private environment variables]&#40;/tutorial/kit/env-static-private&#41;, it's preferable to use static values if possible, but if necessary we can use dynamic values instead: ```svelte /// file: src/routes/+page.svelte <script> import {env} from '$env/dynamic/public'; </script> <main style:background={env.PUBLIC_THEME_BACKGROUND} style:color={env.PUBLIC_THEME_FOREGROUND} > {env.PUBLIC_THEME_FOREGROUND} on {env.PUBLIC_THEME_BACKGROUND} </main> ```)

[//]: # ()
[//]: # (## tutorial/04-advanced-sveltekit/07-conclusion/index.md)

[//]: # ()
[//]: # (--- title: Conclusion ---)

[//]: # ()
[//]: # (## tutorial/04-advanced-sveltekit/07-conclusion/01-next-steps/index.md)

[//]: # ()
[//]: # (--- title: Next steps --- Congratulations! If you've made it the entire way through this tutorial, you can now consider yourself a Svelte and SvelteKit expert. You can start building apps on your own machine with [Svelte CLI]&#40;https://www.npmjs.com/package/sv&#41;: `bash npx sv create ` Svelte and SvelteKit will continue to evolve, and so will this tutorial. Check back periodically for updates. To keep up with developments in the Svelte world, join our Discord server at [svelte.dev/chat]&#40;/chat&#41; and follow [Svelte Society]&#40;https://bsky.app/profile/sveltesociety.dev&#41; on BlueSky. We're so happy to welcome you to the Svelte community!)

[//]: # ()
[//]: # (## docs/svelte/02-runes/index.md)

[//]: # ()
[//]: # (--- title: Runes ---)

[//]: # ()
[//]: # (## docs/svelte/02-runes/01-what-are-runes.md)

[//]: # ()
[//]: # (--- title: What are runes? --- > > A letter or mark used as a mystical or magic symbol. Runes are symbols that you use in `.svelte` and `.svelte.js`/`.svelte.ts` files to control the Svelte compiler. If you think of Svelte as a language, runes are part of the syntax — they are _keywords_. Runes have a `$` prefix and look like functions: `js let message = $state&#40;'hello'&#41;; ` They differ from normal JavaScript functions in important ways, however: - You don't need to import them — they are part of the language - They're not values — you can't assign them to a variable or pass them as arguments to a function - Just like JavaScript keywords, they are only valid in certain positions &#40;the compiler will help you if you put them in the wrong place&#41; > Runes didn't exist prior to Svelte 5.)

[//]: # ()
[//]: # (## docs/svelte/02-runes/02-$state.md)

[//]: # ()
[//]: # (--- title: $state --- The `$state`rune allows you to create _reactive state_, which means that your UI _reacts_ when it changes. ```svelte <script> let count = $state&#40;0&#41;; </script> <button onclick={&#40;&#41; => count++}> clicks: {count} </button> ``` Unlike other frameworks you may have encountered, there is no API for interacting with state —`count`is just a number, rather than an object or a function, and you can update it like you would update any other variable. ### Deep state If`$state` is used with an array or a simple object, the result is a deeply reactive _state proxy_. [Proxies]&#40;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy&#41; allow Svelte to run code when you read or write properties, including via methods like `array.push&#40;...&#41;`, triggering granular updates. State is proxified recursively until Svelte finds something other than an array or simple object. In a case like this... ```js let todos = $state&#40;[ { done: false, text: 'add more todos' } ]&#41;; ``` ...modifying an individual todo's property will trigger updates to anything in your UI that depends on that specific property: ```js let todos = [{ done: false, text: 'add more todos' }]; //cut todos[0].done = !todos[0].done; ``` If you push a new object to the array, it will also be proxified: ```js let todos = [{ done: false, text: 'add more todos' }]; //cut todos.push&#40;{ done: false, text: 'eat lunch' }&#41;; ``` Note that if you destructure a reactive value, the references are not reactive — as in normal JavaScript, they are evaluated at the point of destructuring: ```js let todos = [{ done: false, text: 'add more todos' }]; //cut let { done, text } = todos[0]; // this will not affect the value of `done` todos[0].done = !todos[0].done; ``` ### Classes You can also use `$state` in class fields &#40;whether public or private&#41;: ```js // @errors: 7006 2554 class Todo { done = $state&#40;false&#41;; text = $state&#40;&#41;; constructor&#40;text&#41; { this.text = text; } reset&#40;&#41; { this.text = ''; this.done = false; } } ``` When calling methods in JavaScript, the value of [`this`]&#40;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this&#41; matters. This won't work, because `this`inside the`reset`method will be the`<button>`rather than the`Todo`: ```svelte <button onclick={todo.reset}> reset </button> ``` You can either use an inline function... ```svelte <button onclick={&#40;&#41; => todo.reset&#40;&#41;}> reset </button> ``` ...or use an arrow function in the class definition: ```js // @errors: 7006 2554 class Todo { done = $state&#40;false&#41;; text = $state&#40;&#41;; constructor&#40;text&#41; { this.text = text; } reset = &#40;&#41; => { this.text = ''; this.done = false; } } ``` ## `$state.raw` In cases where you don't want objects and arrays to be deeply reactive you can use `$state.raw`. State declared with `$state.raw` cannot be mutated; it can only be _reassigned_. In other words, rather than assigning to a property of an object, or using an array method like `push`, replace the object or array altogether if you'd like to update it: ```js let person = $state.raw&#40;{ name: 'Heraclitus', age: 49 }&#41;; // this will have no effect person.age += 1; // this will work, because we're creating a new person person = { name: 'Heraclitus', age: 50 }; ``` This can improve performance with large arrays and objects that you weren't planning to mutate anyway, since it avoids the cost of making them reactive. Note that raw state can _contain_ reactive state &#40;for example, a raw array of reactive objects&#41;. ## `$state.snapshot`To take a static snapshot of a deeply reactive`$state` proxy, use `$state.snapshot`: ```svelte <script> let counter = $state&#40;{ count: 0 }&#41;; function onclick&#40;&#41; { // Will log `{ count: ... }`rather than`Proxy { ... }`console.log&#40;$state.snapshot&#40;counter&#41;&#41;; } </script> ``` This is handy when you want to pass some state to an external library or API that doesn't expect a proxy, such as`structuredClone`. ## Passing state into functions JavaScript is a _pass-by-value_ language — when you call a function, the arguments are the _values_ rather than the _variables_. In other words: ```js /// file: index.js // @filename: index.js //cut /** * @param {number} a * @param {number} b */ function add&#40;a, b&#41; { return a + b; } let a = 1; let b = 2; let total = add&#40;a, b&#41;; console.log&#40;total&#41;; // 3 a = 3; b = 4; console.log&#40;total&#41;; // still 3! ``` If `add`wanted to have access to the _current_ values of`a`and`b`, and to return the current `total`value, you would need to use functions instead: ```js /// file: index.js // @filename: index.js //cut /** * @param {&#40;&#41; => number} getA * @param {&#40;&#41; => number} getB */ function add&#40;getA, getB&#41; { return&#40;&#41; => getA&#40;&#41; + getB&#40;&#41;; } let a = 1; let b = 2; let total = add&#40;&#40;&#41; => a, &#40;&#41; => b&#41;; console.log&#40;total&#40;&#41;&#41;; // 3 a = 3; b = 4; console.log&#40;total&#40;&#41;&#41;; // 7 ``` State in Svelte is no different — when you reference something declared with the`$state` rune... ```js let a =$state&#40;1&#41;; let b =$state&#40;2&#41;; ``` ...you're accessing its _current value_. Note that 'functions' is broad — it encompasses properties of proxies and [`get`]&#40;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get&#41;/[`set`]&#40;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set&#41; properties... ```js /// file: index.js // @filename: index.js //cut /** * @param {{ a: number, b: number }} input */ function add&#40;input&#41; { return { get value&#40;&#41; { return input.a + input.b; } }; } let input = $state&#40;{ a: 1, b: 2 }&#41;; let total = add&#40;input&#41;; console.log&#40;total.value&#41;; // 3 input.a = 3; input.b = 4; console.log&#40;total.value&#41;; // 7 ``` ...though if you find yourself writing code like that, consider using [classes]&#40;#Classes&#41; instead. ## Passing state across modules You can declare state in `.svelte.js` and `.svelte.ts` files, but you can only _export_ that state if it's not directly reassigned. In other words you can't do this: ```js /// file: state.svelte.js export let count = $state&#40;0&#41;; export function increment&#40;&#41; { count += 1; } ``` That's because every reference to `count` is transformed by the Svelte compiler — the code above is roughly equivalent to this: ```js /// file: state.svelte.js &#40;compiler output&#41; // @filename: index.ts interface Signal<T> { value: T; } interface Svelte { state<T>&#40;value?: T&#41;: Signal<T>; get<T>&#40;source: Signal<T>&#41;: T; set<T>&#40;source: Signal<T>, value: T&#41;: void; } declare const $: Svelte; //cut export let count = $.state&#40;0&#41;; export function increment&#40;&#41; { $.set&#40;count, $.get&#40;count&#41; + 1&#41;; } ``` Since the compiler only operates on one file at a time, if another file imports `count` Svelte doesn't know that it needs to wrap each reference in `$.get`and`$.set`: ```js // @filename: state.svelte.js export let count = 0; // @filename: index.js //cut import { count } from './state.svelte.js'; console.log&#40;typeof count&#41;; // 'object', not 'number' ``` This leaves you with two options for sharing state between modules — either don't reassign it... ```js // This is allowed — since we're updating // `counter.count` rather than `counter`, // Svelte doesn't wrap it in `$.state`export const counter = $state&#40;{ count: 0 }&#41;; export function increment&#40;&#41; { counter.count += 1; }`...or don't directly export it:`js let count = $state&#40;0&#41;; export function getCount&#40;&#41; { return count; } export function increment&#40;&#41; { count += 1; } ```)

[//]: # ()
[//]: # (## docs/svelte/02-runes/03-$derived.md)

[//]: # ()
[//]: # (--- title: $derived --- Derived state is declared with the `$derived`rune: ```svelte <script> let count = $state&#40;0&#41;; let doubled = $derived&#40;count * 2&#41;; </script> <button onclick={&#40;&#41; => count++}> {doubled} </button> <p>{count} doubled is {doubled}</p> ``` The expression inside`$derived&#40;...&#41;` should be free of side-effects. Svelte will disallow state changes &#40;e.g. `count++`&#41; inside derived expressions. As with `$state`, you can mark class fields as `$derived`. ## `$derived.by`Sometimes you need to create complex derivations that don't fit inside a short expression. In these cases, you can use`$derived.by` which accepts a function as its argument. ```svelte <script> let numbers = $state&#40;[1, 2, 3]&#41;; let total = $derived.by&#40;&#40;&#41; => { let total = 0; for &#40;const n of numbers&#41; { total += n; } return total; }&#41;; </script> <button onclick={&#40;&#41; => numbers.push&#40;numbers.length + 1&#41;}> {numbers.join&#40;' + '&#41;} = {total} </button> ``` In essence, `$derived&#40;expression&#41;`is equivalent to`$derived.by&#40;&#40;&#41; => expression&#41;`. ## Understanding dependencies Anything read synchronously inside the `$derived`expression &#40;or`$derived.by` function body&#41; is considered a _dependency_ of the derived state. When the state changes, the derived will be marked as _dirty_ and recalculated when it is next read. To exempt a piece of state from being treated as a dependency, use [`untrack`]&#40;svelte#untrack&#41;. ## Overriding derived values Derived expressions are recalculated when their dependencies change, but you can temporarily override their values by reassigning them &#40;unless they are declared with `const`&#41;. This can be useful for things like _optimistic UI_, where a value is derived from the 'source of truth' &#40;such as data from your server&#41; but you'd like to show immediate feedback to the user: ```svelte <script> let { post, like } = $props&#40;&#41;; let likes = $derived&#40;post.likes&#41;; async function onclick&#40;&#41; { // increment the `likes` count immediately... likes += 1; // and tell the server, which will eventually update `post` try { await like&#40;&#41;; } catch { // failed! roll back the change likes -= 1; } } </script> <button {onclick}>🧡 {likes}</button> ``` ## Deriveds and reactivity Unlike `$state`, which converts objects and arrays to [deeply reactive proxies]&#40;$state#Deep-state&#41;, `$derived`values are left as-is. For example, [in a case like this]&#40;/REMOVED&#41;... ```svelte let items = $state&#40;[...]&#41;; let index = $state&#40;0&#41;; let selected = $derived&#40;items[index]&#41;; ``` ...you can change &#40;or`bind:`to&#41; properties of`selected`and it will affect the underlying`items`array. If`items`was _not_ deeply reactive, mutating`selected`would have no effect. ## Update propagation Svelte uses something called _push-pull reactivity_ — when state is updated, everything that depends on the state &#40;whether directly or indirectly&#41; is immediately notified of the change &#40;the 'push'&#41;, but derived values are not re-evaluated until they are actually read &#40;the 'pull'&#41;. If the new value of a derived is referentially identical to its previous value, downstream updates will be skipped. In other words, Svelte will only update the text inside the button when`large`changes, not when`count`changes, even though`large`depends on`count`: `svelte <script> let count = $state&#40;0&#41;; let large = $derived&#40;count > 10&#41;; </script> <button onclick={&#40;&#41; => count++}> {large} </button> `)

[//]: # ()
[//]: # (## docs/svelte/02-runes/04-$effect.md)

[//]: # ()
[//]: # (--- title: $effect --- Effects are functions that run when state updates, and can be used for things like calling third-party libraries, drawing on `<canvas>` elements, or making network requests. They only run in the browser, not during server-side rendering. Generally speaking, you should _not_ update state inside effects, as it will make code more convoluted and will often lead to never-ending update cycles. If you find yourself doing so, see [when not to use `$effect`]&#40;#When-not-to-use-$effect&#41; to learn about alternative approaches. You can create an effect with the `$effect` rune &#40;[demo]&#40;/REMOVED&#41;&#41;: ```svelte <script> let size = $state&#40;50&#41;; let color = $state&#40;'#ff3e00'&#41;; let canvas; $effect&#40;&#40;&#41; => { const context = canvas.getContext&#40;'2d'&#41;; context.clearRect&#40;0, 0, canvas.width, canvas.height&#41;; // this will re-run whenever `color` or `size` change context.fillStyle = color; context.fillRect&#40;0, 0, size, size&#41;; }&#41;; </script> <canvas bind:this={canvas} width="100" height="100"></canvas> ``` When Svelte runs an effect function, it tracks which pieces of state &#40;and derived state&#41; are accessed &#40;unless accessed inside [`untrack`]&#40;svelte#untrack&#41;&#41;, and re-runs the function when that state later changes. ### Understanding lifecycle Your effects run after the component has been mounted to the DOM, and in a [microtask]&#40;https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide&#41; after state changes. Re-runs are batched &#40;i.e. changing `color` and `size` in the same moment won't cause two separate runs&#41;, and happen after any DOM updates have been applied. You can use `$effect`anywhere, not just at the top level of a component, as long as it is called while a parent effect is running. An effect can return a _teardown function_ which will run immediately before the effect re-runs &#40;[demo]&#40;/REMOVED&#41;&#41;. ```svelte <script> let count = $state&#40;0&#41;; let milliseconds = $state&#40;1000&#41;; $effect&#40;&#40;&#41; => { // This will be recreated whenever`milliseconds`changes const interval = setInterval&#40;&#40;&#41; => { count += 1; }, milliseconds&#41;; return &#40;&#41; => { // if a teardown function is provided, it will run // a&#41; immediately before the effect re-runs // b&#41; when the component is destroyed clearInterval&#40;interval&#41;; }; }&#41;; </script> <h1>{count}</h1> <button onclick={&#40;&#41; => &#40;milliseconds *= 2&#41;}>slower</button> <button onclick={&#40;&#41; => &#40;milliseconds /= 2&#41;}>faster</button> ``` Teardown functions also run when the effect is destroyed, which happens when its parent is destroyed &#40;for example, a component is unmounted&#41; or the parent effect re-runs. ### Understanding dependencies`$effect` automatically picks up any reactive values &#40;`$state`, `$derived`, `$props`&#41; that are _synchronously_ read inside its function body &#40;including indirectly, via function calls&#41; and registers them as dependencies. When those dependencies change, the `$effect` schedules a re-run. If `$state`and`$derived` are used directly inside the `$effect`&#40;for example, during creation of a [reactive class]&#40;https://svelte.dev/docs/svelte/$state#Classes&#41;&#41;, those values will _not_ be treated as dependencies. Values that are read _asynchronously_ — after an`await`or inside a`setTimeout`, for example — will not be tracked. Here, the canvas will be repainted when `color`changes, but not when`size`changes &#40;[demo]&#40;/REMOVED&#41;&#41;: ```ts // @filename: index.ts declare let canvas: { width: number; height: number; getContext&#40;type: '2d', options?: CanvasRenderingContext2DSettings&#41;: CanvasRenderingContext2D; }; declare let color: string; declare let size: number; //cut $effect&#40;&#40;&#41; => { const context = canvas.getContext&#40;'2d'&#41;; context.clearRect&#40;0, 0, canvas.width, canvas.height&#41;; // this will re-run whenever`color`changes... context.fillStyle = color; setTimeout&#40;&#40;&#41; => { // ...but not when`size` changes context.fillRect&#40;0, 0, size, size&#41;; }, 0&#41;; }&#41;; ``` An effect only reruns when the object it reads changes, not when a property inside it changes. &#40;If you want to observe changes _inside_ an object at dev time, you can use [`$inspect`]&#40;$inspect&#41;.&#41; ``svelte <script> let state = $state&#40;{ value: 0 }&#41;; let derived = $derived&#40;{ value: state.value * 2 }&#41;; // this will run once, because `state` is never reassigned &#40;only mutated&#41; $effect&#40;&#40;&#41; => { state; }&#41;; // this will run whenever `state.value` changes... $effect&#40;&#40;&#41; => { state.value; }&#41;; // ...and so will this, because `derived` is a new object each time $effect&#40;&#40;&#41; => { derived; }&#41;; </script> <button onclick={&#40;&#41; => &#40;state.value += 1&#41;}> {state.value} </button> <p>{state.value} doubled is {derived.value}</p> `` An effect only depends on the values that it read the last time it ran. This has interesting implications for effects that have conditional code. For instance, if `condition` is `true` in the code snippet below, the code inside the `if` block will run and `color` will be evaluated. As such, changes to either `condition` or `color` [will cause the effect to re-run]&#40;/REMOVED&#41;. Conversely, if `condition` is `false`, `color` will not be evaluated, and the effect will _only_ re-run again when `condition` changes. `ts // @filename: ambient.d.ts declare module 'canvas-confetti' { interface ConfettiOptions { colors: string[]; } function confetti&#40;opts?: ConfettiOptions&#41;: void; export default confetti; } // @filename: index.js //cut import confetti from 'canvas-confetti'; let condition = $state&#40;true&#41;; let color = $state&#40;'#ff3e00'&#41;; $effect&#40;&#40;&#41; => { if &#40;condition&#41; { confetti&#40;{ colors: [color] }&#41;; } else { confetti&#40;&#41;; } }&#41;; ` ## `$effect.pre` In rare cases, you may need to run code _before_ the DOM updates. For this we can use the `$effect.pre` rune: ``svelte <script> import { tick } from 'svelte'; let div = $state&#40;&#41;; let messages = $state&#40;[]&#41;; // ... $effect.pre&#40;&#40;&#41; => { if &#40;!div&#41; return; // not yet mounted // reference `messages` array length so that this code re-runs whenever it changes messages.length; // autoscroll when new messages are added if &#40;div.offsetHeight + div.scrollTop > div.scrollHeight - 20&#41; { tick&#40;&#41;.then&#40;&#40;&#41; => { div.scrollTo&#40;0, div.scrollHeight&#41;; }&#41;; } }&#41;; </script> <div bind:this={div}> {#each messages as message} <p>{message}</p> {/each} </div> `` Apart from the timing, `$effect.pre` works exactly like `$effect`. ## `$effect.tracking` The `$effect.tracking` rune is an advanced feature that tells you whether or not the code is running inside a tracking context, such as an effect or inside your template &#40;[demo]&#40;/REMOVED&#41;&#41;: `svelte <script> console.log&#40;'in component setup:', $effect.tracking&#40;&#41;&#41;; // false $effect&#40;&#40;&#41; => { console.log&#40;'in effect:', $effect.tracking&#40;&#41;&#41;; // true }&#41;; </script> <p>in template: {$effect.tracking&#40;&#41;}</p> ` It is used to implement abstractions like [`createSubscriber`]&#40;/docs/svelte/svelte-reactivity#createSubscriber&#41;, which will create listeners to update reactive values but _only_ if those values are being tracked &#40;rather than, for example, read inside an event handler&#41;. ## `$effect.root` The `$effect.root` rune is an advanced feature that creates a non-tracked scope that doesn't auto-cleanup. This is useful for nested effects that you want to manually control. This rune also allows for the creation of effects outside of the component initialisation phase. `js const destroy = $effect.root&#40;&#40;&#41; => { $effect&#40;&#40;&#41; => { // setup }&#41;; return &#40;&#41; => { // cleanup }; }&#41;; // later... destroy&#40;&#41;; ` ## When not to use `$effect` In general, `$effect` is best considered something of an escape hatch — useful for things like analytics and direct DOM manipulation — rather than a tool you should use frequently. In particular, avoid using it to synchronise state. Instead of this... `svelte <script> let count = $state&#40;0&#41;; let doubled = $state&#40;&#41;; // don't do this! $effect&#40;&#40;&#41; => { doubled = count * 2; }&#41;; </script> ` ...do this: `svelte <script> let count = $state&#40;0&#41;; let doubled = $derived&#40;count * 2&#41;; </script> ` If you're using an effect because you want to be able to reassign the derived value &#40;to build an optimistic UI, for example&#41; note that [deriveds can be directly overridden]&#40;$derived#Overriding-derived-values&#41; as of Svelte 5.25. You might be tempted to do something convoluted with effects to link one value to another. The following example shows two inputs for "money spent" and "money left" that are connected to each other. If you update one, the other should update accordingly. Don't use effects for this &#40;[demo]&#40;/REMOVED&#41;&#41;: `svelte <script> let total = 100; let spent = $state&#40;0&#41;; let left = $state&#40;total&#41;; $effect&#40;&#40;&#41; => { left = total - spent; }&#41;; $effect&#40;&#40;&#41; => { spent = total - left; }&#41;; </script> <label> <input type="range" bind:value={spent} max={total} /> {spent}/{total} spent </label> <label> <input type="range" bind:value={left} max={total} /> {left}/{total} left </label> ` Instead, use `oninput` callbacks or — better still — [function bindings]&#40;bind#Function-bindings&#41; where possible &#40;[demo]&#40;/REMOVED&#41;&#41;: `svelte <script> let total = 100; let spent = $state&#40;0&#41;; let left = $state&#40;total&#41;; function updateSpent&#40;value&#41; { spent = value; left = total - spent; } function updateLeft&#40;value&#41; { left = value; spent = total - left; } </script> <label> <input type="range" bind:value={&#40;&#41; => spent, updateSpent} max={total} /> {spent}/{total} spent </label> <label> <input type="range" bind:value={&#40;&#41; => left, updateLeft} max={total} /> {left}/{total} left </label> ` If you absolutely have to update `$state` within an effect and run into an infinite loop because you read and write to the same `$state`, use [untrack]&#40;svelte#untrack&#41;.)

[//]: # ()
[//]: # (## docs/svelte/02-runes/05-$props.md)

[//]: # ()
[//]: # (--- title: $props --- The inputs to a component are referred to as _props_, which is short for _properties_. You pass props to components just like you pass attributes to elements: ```svelte <!file: App.svelte> <script> import MyComponent from './MyComponent.svelte'; </script> <MyComponent adjective="cool" /> ``` On the other side, inside `MyComponent.svelte`, we can receive props with the `$props`rune... ```svelte <!file: MyComponent.svelte> <script> let props = $props&#40;&#41;; </script> <p>this component is {props.adjective}</p> ``` ...though more commonly, you'll [_destructure_]&#40;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&#41; your props: ```svelte <!file: MyComponent.svelte> <script> let{ adjective }= $props&#40;&#41;; </script> <p>this component is {adjective}</p> ``` ## Fallback values Destructuring allows us to declare fallback values, which are used if the parent component does not set a given prop: ```js let { adjective = 'happy' } = $props&#40;&#41;; ``` ## Renaming props We can also use the destructuring assignment to rename props, which is necessary if they're invalid identifiers, or a JavaScript keyword like`super`: ```js let { super: trouper = 'lights are gonna find me' } = $props&#40;&#41;; ``` ## Rest props Finally, we can use a _rest property_ to get, well, the rest of the props: ```js let { a, b, c, ...others } = $props&#40;&#41;; ``` ## Updating props References to a prop inside a component update when the prop itself updates — when `count`changes in`App.svelte`, it will also change inside `Child.svelte`. But the child component is able to temporarily override the prop value, which can be useful for unsaved ephemeral state &#40;[demo]&#40;/REMOVED&#41;&#41;: ```svelte <!file: App.svelte> <script> import Child from './Child.svelte'; let count = $state&#40;0&#41;; </script> <button onclick={&#40;&#41; => &#40;count += 1&#41;}> clicks &#40;parent&#41;: {count} </button> <Child {count} /> ``` ```svelte <!file: Child.svelte> <script> let { count } = $props&#40;&#41;; </script> <button onclick={&#40;&#41; => &#40;count += 1&#41;}> clicks &#40;child&#41;: {count} </button> ``` While you can temporarily _reassign_ props, you should not _mutate_ props unless they are [bindable]&#40;$bindable&#41;. If the prop is a regular object, the mutation will have no effect &#40;[demo]&#40;/REMOVED&#41;&#41;: ```svelte <!file: App.svelte> <script> import Child from './Child.svelte'; </script> <Child object={{ count: 0 }} /> ``` ```svelte <!file: Child.svelte> <script> let { object } = $props&#40;&#41;; </script> <button onclick={&#40;&#41; => { // has no effect object.count += 1 }}> clicks: {object.count} </button> ``` If the prop is a reactive state proxy, however, then mutations _will_ have an effect but you will see an [`ownership_invalid_mutation`]&#40;runtime-warnings#Client-warnings-ownership_invalid_mutation&#41; warning, because the component is mutating state that does not 'belong' to it &#40;[demo]&#40;/REMOVED&#41;&#41;: ```svelte <!file: App.svelte> <script> import Child from './Child.svelte'; let object = $state&#40;{count: 0}&#41;; </script> <Child {object} /> ``` ```svelte <!file: Child.svelte> <script> let { object } = $props&#40;&#41;; </script> <button onclick={&#40;&#41; => { // will cause the count below to update, // but with a warning. Don't mutate // objects you don't own! object.count += 1 }}> clicks: {object.count} </button> ``` The fallback value of a prop not declared with `$bindable` is left untouched — it is not turned into a reactive state proxy — meaning mutations will not cause updates &#40;[demo]&#40;/REMOVED&#41;&#41; ```svelte <!file: Child.svelte> <script> let { object = { count: 0 } } = $props&#40;&#41;; </script> <button onclick={&#40;&#41; => { // has no effect if the fallback value is used object.count += 1 }}> clicks: {object.count} </button> ``` In summary: don't mutate props. Either use callback props to communicate changes, or — if parent and child should share the same object — use the [`$bindable`]&#40;$bindable&#41; rune. ## Type safety You can add type safety to your components by annotating your props, as you would with any other variable declaration. In TypeScript that might look like this... ```svelte <script lang="ts"> let { adjective }: { adjective: string } = $props&#40;&#41;; </script> ``` ...while in JSDoc you can do this: ```svelte <script> /** @type {{ adjective: string }} */ let { adjective } = $props&#40;&#41;; </script> ``` You can, of course, separate the type declaration from the annotation: ```svelte <script lang="ts"> interface Props { adjective: string; } let { adjective }: Props = $props&#40;&#41;; </script> ``` Adding types is recommended, as it ensures that people using your component can easily discover which props they should provide. ## `$props.id&#40;&#41;`This rune, added in version 5.20.0, generates an ID that is unique to the current component instance. When hydrating a server-rendered component, the value will be consistent between server and client. This is useful for linking elements via attributes like`for`and`aria-labelledby`. `svelte <script> const uid = $props.id&#40;&#41;; </script> <form> <label for="{uid}-firstname">First Name: </label> <input id="{uid}-firstname" type="text" /> <label for="{uid}-lastname">Last Name: </label> <input id="{uid}-lastname" type="text" /> </form> `)

[//]: # ()
[//]: # (## docs/svelte/02-runes/06-$bindable.md)

[//]: # ()
[//]: # (--- title: $bindable --- Ordinarily, props go one way, from parent to child. This makes it easy to understand how data flows around your app. In Svelte, component props can be _bound_, which means that data can also flow _up_ from child to parent. This isn't something you should do often, but it can simplify your code if used sparingly and carefully. It also means that a state proxy can be _mutated_ in the child. To mark a prop as bindable, we use the `$bindable`rune: ```svelte /// file: FancyInput.svelte <script> let { value = $bindable&#40;&#41;, ...props } = $props&#40;&#41;; </script> <input bind:value={value} {...props} /> <style> input { font-family: 'Comic Sans MS'; color: deeppink; } </style> ``` Now, a component that uses`<FancyInput>` can add the [`bind:`]&#40;bind&#41; directive &#40;[demo]&#40;/REMOVED&#41;&#41;: ```svelte /// file: App.svelte <script> import FancyInput from './FancyInput.svelte'; let message = $state&#40;'hello'&#41;; </script> <FancyInput bind:value={message} /> <p>{message}</p> ``` The parent component doesn't _have_ to use `bind:`— it can just pass a normal prop. Some parents don't want to listen to what their children have to say. In this case, you can specify a fallback value for when no prop is passed at all:`js /// file: FancyInput.svelte let { value = $bindable&#40;'fallback'&#41;, ...props } = $props&#40;&#41;; `)

[//]: # ()
[//]: # (## docs/svelte/02-runes/07-$inspect.md)

[//]: # ()
[//]: # (--- title: $inspect --- The `$inspect`rune is roughly equivalent to`console.log`, with the exception that it will re-run whenever its argument changes. `$inspect` tracks reactive state deeply, meaning that updating something inside an object or array using fine-grained reactivity will cause it to re-fire &#40;[demo]&#40;/REMOVED&#41;&#41;: ```svelte <script> let count = $state&#40;0&#41;; let message = $state&#40;'hello'&#41;; $inspect&#40;count, message&#41;; // will console.log when `count` or `message` change </script> <button onclick={&#40;&#41; => count++}>Increment</button> <input bind:value={message} /> ``` ## $inspect&#40;...&#41;.with `$inspect`returns a property`with`, which you can invoke with a callback, which will then be invoked instead of `console.log`. The first argument to the callback is either `"init"`or`"update"`; subsequent arguments are the values passed to `$inspect` &#40;[demo]&#40;/REMOVED&#41;&#41;: ```svelte <script> let count = $state&#40;0&#41;; $inspect&#40;count&#41;.with&#40;&#40;type, count&#41; => { if &#40;type === 'update'&#41; { debugger; // or `console.trace`, or whatever you want } }&#41;; </script> <button onclick={&#40;&#41; => count++}>Increment</button> ``` A convenient way to find the origin of some change is to pass `console.trace` to `with`: ```js // @errors: 2304 $inspect&#40;stuff&#41;.with&#40;console.trace&#41;; ``` ## $inspect.trace&#40;...&#41; This rune, added in 5.14, causes the surrounding function to be _traced_ in development. Any time the function re-runs as part of an [effect]&#40;$effect&#41; or a [derived]&#40;$derived&#41;, information will be printed to the console about which pieces of reactive state caused the effect to fire. `svelte <script> import { doSomeWork } from './elsewhere'; $effect&#40;&#40;&#41; => { $inspect.trace&#40;&#41;; doSomeWork&#40;&#41;; }&#41;; </script> ` `$inspect.trace` takes an optional first argument which will be used as the label.)

[//]: # ()
[//]: # (## docs/svelte/02-runes/08-$host.md)

[//]: # ()
[//]: # (--- title: $host --- When compiling a component as a [custom element]&#40;custom-elements&#41;, the `$host`rune provides access to the host element, allowing you to &#40;for example&#41; dispatch custom events &#40;[demo]&#40;/REMOVED&#41;&#41;:`svelte /// file: Stepper.svelte <svelte:options customElement="my-stepper" /> <script> function dispatch&#40;type&#41; { $host&#40;&#41;.dispatchEvent&#40;new CustomEvent&#40;type&#41;&#41;; } </script> <button onclick={&#40;&#41; => dispatch&#40;'decrement'&#41;}>decrement</button> <button onclick={&#40;&#41; => dispatch&#40;'increment'&#41;}>increment</button> ` `svelte /// file: App.svelte <script> import './Stepper.svelte'; let count = $state&#40;0&#41;; </script> <my-stepper ondecrement={&#40;&#41; => count -= 1} onincrement={&#40;&#41; => count += 1} ></my-stepper> <p>count: {count}</p> `)

[//]: # ()
[//]: # (Instructions for LLMs: <SYSTEM>Always use Svelte 5 runes and Svelte 5 syntax. Runes do not need to be imported, they are globals. $state&#40;&#41; runes are always declared using `let`, never with `const`. When passing a function to $derived, you must always use $derived.by&#40;&#40;&#41; => ...&#41;. Error boundaries can only catch errors during component rendering and at the top level of an $effect inside the error boundary. Error boundaries do not catch errors in onclick or other event handlers.</SYSTEM>)

[//]: # ()
[//]: # (--- title: About description: Powered by amazing open source projects. --- ## About is a port of for Svelte/SvelteKit. It's maintained by and and has received countless contributions from the community. ## Credits - - The brilliant mind behind the designs, methodology, and implementation of the original . - - The headless components that power this project. - - The form components that power this project. - - The resizable components that power this project. - - The drawer components that power this project. - - The command menu components that power this project. - - The headless primitive component builders that power this project. - - The headless components and examples that the original was built on. - - The typography style is adapted from his work on Nextra. - - Where shad copied the styles for the first component: the `Button`. ## License MIT © & --- title: Changelog description: Latest updates and announcements. --- <script> import { Steps, Callout, ComponentPreview } from '$lib/components/docs' import DashboardDark from '$lib/img/blocks/dashboard-1-dark.jpg?enhanced'; import DashboardLight from '$lib/img/blocks/dashboard-1.jpg?enhanced'; </script> ## March 2024 ### Introducing Blocks  are ready-made components that you can use to build your apps. They are fully responsive, accessible, and composable, meaning they are built using the same principles as the rest of the components in shadcn-svelte. <enhanced:img src={DashboardDark} alt="A screenshot of the dashboard-01 block" class="h-full w-full hidden dark:block mt-6" /> <enhanced:img src={DashboardLight} alt="A screenshot of the dashboard-01 block" class="h-full w-full block dark:hidden mt-6" />  only supports React at the moment, so you can't customize them like you can the original from . However, if having support for Svelte interests you, I'm sure the v0 team would love to hear about it. :&#41; ### New Component: Breadcrumb We've added a new component to the project, . <ComponentPreview name="breadcrumb-demo"> <div /> </ComponentPreview> ### New Component: Scroll Area We've added a new component to the project, , which is built on top of the  component from Bits UI. It supports both vertical and horizontal scrolling, and is designed to provide a consistent experience across all browsers and platforms. #### Examples <ComponentPreview name="scroll-area-demo"> <div /> </ComponentPreview> <ComponentPreview name="scroll-area-horizontal"> <div /> </ComponentPreview> ## February 2024 ### New Component: Resizable We've added a new component to the project, , which is built on top of . PaneForge is still in an early stage, so be sure to raise any issues you find with the library on the . <ComponentPreview name="resizable-demo"> <div /> </ComponentPreview> ### Updated Icon Imports After some feedback about dev server performance, we've updated the way we import icons. With this change, we've decided to move away from the unmaintained `radix-icons-svelte` package to  for the `new-york` style. Instead of importing icons like so:  We now import them directly:  With deep imports, we're preventing Vite from optimizing the entire icon collections, and instead only optimizing the icons that are actually used in your project. From what we've seen, this has a massive impact on dev server performance. Enjoy! 🚀 ### Major Forms Update Formsnap has been completely rewritten to be more flexible, easier to use, and less opinionated. This means we've had to make some changes to the way we use it in `shadcn-svelte`, but once you get the hang of it, you'll find it's much more powerful and less restrictive than the previous iteration. Since the changes are so significant, there isn't a direct migration path from the old version to the new version. You'll need to update your components to use the new API, as well as ensure you're using the latest version of `formsnap` and `sveltekit-superforms`. All of the `Form` components have been updated to use the new API, and you can see live examples of them on the  page. Visit the  documentation  to learn more about the new API and how its used. ## January 2024 We've added four new components to the project, , , , & . ### New Component: Carousel We've added a new component to the project, . <ComponentPreview name="carousel-demo"> <div /> </ComponentPreview> ### New Component: Drawer The Drawer is built on top of  and is a port of , originally created by  for React. <ComponentPreview name="drawer-demo"> <div/> </ComponentPreview> ### New Component: Sonner The Sonner component is provided by , which is a Svelte port of , originally created by  for React. <ComponentPreview name="sonner-demo"> <div/> </ComponentPreview> ### New Component: Pagination Pagination leverages the  component from Bits UI. <ComponentPreview name="pagination-demo"> <div/> </ComponentPreview> ## December 2023 We've added three new components to the project, , , & . ### New Component: Calendar <ComponentPreview name="calendar-demo"> <div/> </ComponentPreview> ### New Component: Range Calendar <ComponentPreview name="range-calendar-demo"> <div/> </ComponentPreview> ### New Component: Date Picker <ComponentPreview name="date-picker-demo"> <div/> </ComponentPreview> ## November 2023 ### New Component: Toggle Group We've added a new component to the library, . <ComponentPreview name="toggle-group-demo"> <div /> </ComponentPreview> ## October 2023 We've added two new components to the library,  & . We've also made some updates to the `<Form.Label />` component that you'll want to be aware of. ### New Component: Command Command is a component that allows you to create a command palette. It's built on top of , which is a Svelte port of . The library is still in its infancy, but we're excited to see where it goes. If you notice any issues, please  with the library. <ComponentPreview name="command-dialog"> <div /> </ComponentPreview> Be sure to check out the  docs for more information. ### New Component: Combobox Combobox is a combination of the `<Command />` & `<Popover />` components. It allows you to create a searchable dropdown menu. <ComponentPreview name="combobox-demo"> <div /> </ComponentPreview> Be sure to check out the  docs for more information. ### Updates to Form #### Form.Label Changes Since we had to make some internal changes to formsnap to fix outstanding issues, there is a slight modification we have to make to the `<Form.Label />` component. The `ids` returned from `getFormField` is now a store, so we need to prefix it with `$`when we use it.  ### Form.Control Formsnap introduced a new component`<Form.Control />`which wraps non-traditional form elements. This allows us to ensure the components are accessible, and work well with the rest of the form components. You'll need to define & export that control in your`form/index.ts`file.  ## August 2023 - Transitions & More ### Transitions To support both enter and exit transitions, we've had to move from`tailwindcss-animate`to . You can still use the`tailwindcss-animate`if you'd like, but you won't have exit transitions on most components. To get the updated transition support, be sure to upgrade to the latest version of`bits-ui`, which at the time of this writing is `0.5.0`. We now provide a custom transition `flyAndScale`&#41; which most components use. It's added to the`utils.ts`file when you`init`a new project. #### Migration If you're using`tailwindcss-animate`and want to migrate to the new transition system, you'll need to do the following: Update your`utils.ts`file to include the`flyAndScale`transition:  Inside the components that use transitions/animations, you'll need to remove the animation classes and add the transition. Here's an example of the`AlertDialog.Content`component:  If you're unsure which specific classes should be removed, you can reference the components in the  to see the changes. ### Events Previous, we were using the same syntax as  for events, as we were simply forwarding them. So you'd have to do`on:m-click`or`on:m-keydown`. While this isn't a huge deal, since we're using components, we decided we wanted to use the same syntax as you would for any other Svelte component. So now you can just do `on:click`or`on:keydown`. Behind the scenes, we're redispatching the event, so the contents of the event are the same, but the syntax is a bit more familiar. #### Migration To migrate to the new event syntax, you'll need to update your components that are forwarding the `m-`events. Ensure you're on the latest version of`bits-ui`before doing so. --- title: CLI description: Use the CLI to add components to your project. --- <script> import { PMExecute } from '$lib/components/docs' </script> ## init Use the`init`command to initialize dependencies for a new project. The`init`command installs dependencies, adds the`cn`util, configures`tailwind.config.cjs`, and creates CSS variables for the project. <PMExecute command="shadcn-svelte@latest init" /> You will be asked a few questions to configure `components.json`:  ### Options  ## add Use the `add`command to add components and dependencies to your project. <PMExecute command="shadcn-svelte@latest add " /> You will be presented with a list of components to choose from:  ### Options  ## update Use the`update`command to update components in your project. This will overwrite any modifications you've made to the components, so be sure to commit your changes before running this command. <PMExecute command="shadcn-svelte@latest update " /> ### Options  ## Outgoing Requests ### Proxy This enables the use of a proxy when sending out requests to fetch from the`shadcn`registry. If the`HTTP*PROXY`or`http_proxy`environment variables have been set, the request library underneath will respect the proxy settings. --- title: components.json description: Configuration for your project. --- <script> import { Callout, ComponentPreview, PMExecute } from '$lib/components/docs' </script> The`components.json`file holds configuration for your project. We use it to understand how your project is set up and how to generate components customized for your project. <Callout class="mt-6"> Note: The <code>components.json</code> file is optional and **only required if you're using the CLI** to add components to your project. If you're using the copy and paste method, you don't need this file. </Callout> You can create a`components.json`file in your project by running the following command: <PMExecute command="shadcn-svelte@latest init" /> See the  for more information. ## $schema You can see the JSON Schema for`components.json`.  ## style The style for your components. **This cannot be changed after initialization.**  <ComponentPreview name="card-with-form"> <div /> </ComponentPreview> ## tailwind Configuration to help the CLI understand how Tailwind CSS is set up in your project. See the  for how to set up Tailwind CSS. ### tailwind.config Path to where your`tailwind.config.js`file is located.  ### tailwind.css Path to the CSS file that imports Tailwind CSS into your project.  ### tailwind.baseColor This is used to generate the default color palette for your components. **This cannot be changed after initialization.**  ## aliases The CLI uses these values and the`alias`config from your`svelte.config.js`file to place generated components in the correct location. Path aliases have to be set up in your`svelte.config.js`file. ### aliases.utils Import alias for your utility functions.  ### aliases.components Import alias for your components.  ## Typescript --- title: Accordion description: A vertically stacked set of interactive headings that each reveal a section of content. component: true source: https://github.com/huntabyte/shadcn-svelte/tree/main/sites/docs/src/lib/registry/default/ui/accordion bits: https://www.bits-ui.com/docs/components/accordion --- <script> import { ComponentPreview, ManualInstall, PMAddComp, PMInstall } from '$lib/components/docs'; </script> <ComponentPreview name="accordion-demo" class="]:sm:max-w-"> <div /> </ComponentPreview> ## Installation <PMAddComp name="accordion" /> <ManualInstall> 1. Install`bits-ui`: <PMInstall command="bits-ui" /> 2. Copy and paste the component source files linked at the top of this page into your project. </ManualInstall> ## Usage --- title: Alert Dialog description: A modal dialog that interrupts the user with important content and expects a response. featured: true component: true source: https://github.com/huntabyte/shadcn-svelte/tree/main/sites/docs/src/lib/registry/default/ui/alert-dialog bits: https://www.bits-ui.com/docs/components/alert-dialog --- <script> import { ComponentPreview, ManualInstall, PMAddComp, PMInstall } from '$lib/components/docs'; </script> <ComponentPreview name="alert-dialog-demo"> <div /> </ComponentPreview> ## Installation <PMAddComp name="alert-dialog" /> <ManualInstall> 1. Install `bits-ui`: <PMInstall command="bits-ui" /> 2. Copy and paste the component source files linked at the top of this page into your project. </ManualInstall> ## Usage --- title: Alert description: Displays a callout for user attention. component: true source: https://github.com/huntabyte/shadcn-svelte/tree/main/sites/docs/src/lib/registry/default/ui/alert --- <script> import { ComponentPreview, ManualInstall, PMAddComp } from '$lib/components/docs'; </script> <ComponentPreview name="alert-demo"> <div /> </ComponentPreview> ## Installation <PMAddComp name="alert" /> <ManualInstall> 1. Copy and paste the component source files linked at the top of this page into your project. </ManualInstall> ## Usage  ## Examples ### Default <ComponentPreview name="alert-demo"> <div /> </ComponentPreview> ### Destructive <ComponentPreview name="alert-destructive"> <div /> </ComponentPreview> --- title: Aspect Ratio description: Displays content within a desired ratio. component: true source: https://github.com/huntabyte/shadcn-svelte/tree/main/sites/docs/src/lib/registry/default/ui/aspect-ratio bits: https://www.bits-ui.com/docs/components/aspect-ratio --- <script> import { ComponentPreview, ManualInstall, PMAddComp, PMInstall } from '$lib/components/docs'; </script> <ComponentPreview name="aspect-ratio-demo"> <div/> </ComponentPreview> ## Installation <PMAddComp name="aspect-ratio" /> <ManualInstall> 1. Install `bits-ui`: <PMInstall command="bits-ui" /> 2. Copy and paste the component source files linked at the top of this page into your project. </ManualInstall> ## Usage --- title: Avatar description: An image element with a fallback for representing the user. component: true source: https://github.com/huntabyte/shadcn-svelte/tree/main/sites/docs/src/lib/registry/default/ui/avatar bits: https://www.bits-ui.com/docs/components/avatar --- <script> import { ComponentPreview, ManualInstall, PMAddComp, PMInstall } from '$lib/components/docs'; </script> <ComponentPreview name="avatar-demo"> <div/> </ComponentPreview> ## Installation <PMAddComp name="avatar" /> <ManualInstall> 1. Install `bits-ui`: <PMInstall command="bits-ui" /> 2. Copy and paste the component source files linked at the top of this page into your project. </ManualInstall> ## Usage --- title: Badge description: Displays a badge or a component that looks like a badge. component: true source: https://github.com/huntabyte/shadcn-svelte/tree/main/sites/docs/src/lib/registry/default/ui/badge --- <script> import { ComponentPreview, ManualInstall, PMAddComp } from '$lib/components/docs'; import { BadgeDemo, BadgeDestructive, BadgeOutline, BadgeSecondary } from '$lib/registry/default/example' </script> <ComponentPreview name="badge-demo"> <div /> </ComponentPreview> ## Installation <PMAddComp name="badge" /> <ManualInstall> 1. Copy and paste the component source files linked at the top of this page into your project. </ManualInstall> ## Usage   ### Link You can use the `badgeVariants`helper to create a link that looks like a badge.  ## Examples ### Default <ComponentPreview name="badge-demo"> <div /> </ComponentPreview> --- ### Secondary <ComponentPreview name="badge-secondary"> <div /> </ComponentPreview> --- ### Outline <ComponentPreview name="badge-outline"> <div /> </ComponentPreview> --- ### Destructive <ComponentPreview name="badge-destructive"> <div /> </ComponentPreview> --- title: Breadcrumb description: Displays the path to the current resource using a hierarchy of links. component: true source: https://github.com/huntabyte/shadcn-svelte/tree/main/sites/docs/src/lib/registry/default/ui/breadcrumb --- <script> import { ComponentPreview, ManualInstall, PMAddComp } from '$lib/components/docs'; </script> <ComponentPreview name="breadcrumb-demo"> <div /> </ComponentPreview> ## Installation <PMAddComp name="breadcrumb" /> <ManualInstall> 1. Copy and paste the component source files linked at the top of this page into your project. </ManualInstall> ## Usage  ## Examples ### Custom separator Use a custom component in the`<slot>`of`<Breadcrumb.Separator />`to create a custom separator. <ComponentPreview name="breadcrumb-separator"> <div /> </ComponentPreview> --- ### Dropdown You can compose`<Breadcrumb.Item />`with a`<DropdownMenu />`to create a dropdown in the breadcrumb. <ComponentPreview name="breadcrumb-dropdown"> <div /> </ComponentPreview> --- ### Collapsed We provide a`<Breadcrumb.Ellipsis />`component to show a collapsed state when the breadcrumb is too long. <ComponentPreview name="breadcrumb-ellipsis"> <div /> </ComponentPreview> --- ### Link component To use a custom link component from your routing library, you can use the`asChild`prop on`<Breadcrumb.Link />`. <ComponentPreview name="breadcrumb-link"> <div /> </ComponentPreview> --- ### Responsive Here's an example of a responsive breadcrumb that composes `<Breadcrumb.Item />`with`<Breadcrumb.Ellipsis />`, `<DropdownMenu />`, and `<Drawer />`. It displays a dropdown on desktop and a drawer on mobile. <ComponentPreview name="breadcrumb-responsive"> <div /> </ComponentPreview> --- title: Button description: Displays a button or a component that looks like a button. featured: true component: true source: https://github.com/huntabyte/shadcn-svelte/tree/main/sites/docs/src/lib/registry/default/ui/button bits: https://www.bits-ui.com/docs/components/button --- <script> import { ComponentPreview, ManualInstall, PMAddComp, PMInstall } from '$lib/components/docs'; </script> <ComponentPreview name="button-demo"> <div /> </ComponentPreview> ## Installation <PMAddComp name="button" /> <ManualInstall> 1. Install `bits-ui`: <PMInstall command="bits-ui" /> 2. Copy and paste the component source files linked at the top of this page into your project. </ManualInstall> ## Usage   ### Link You can convert the `<button>`into an`<a>`element by simply passing an`href`as a prop.  Alternatively, you can use the`buttonVariants`helper to create a link that looks like a button.  ## Examples ### Primary <ComponentPreview name="button-demo"> <div /> </ComponentPreview> --- ### Secondary <ComponentPreview name="button-secondary"> <div /> </ComponentPreview> --- ### Destructive <ComponentPreview name="button-destructive"> <div /> </ComponentPreview> --- ### Outline <ComponentPreview name="button-outline"> <div /> </ComponentPreview> --- ### Ghost <ComponentPreview name="button-ghost"> <div /> </ComponentPreview> --- ### Link <ComponentPreview name="button-link"> <div /> </ComponentPreview> --- ### With Icon <ComponentPreview name="button-with-icon"> <div /> </ComponentPreview> --- ### Icon <ComponentPreview name="button-icon"> <div /> </ComponentPreview> --- ### Loading <ComponentPreview name="button-loading"> <div /> </ComponentPreview> --- title: Calendar description: A calendar component that allows users to select dates. component: true source: https://github.com/huntabyte/shadcn-svelte/tree/main/sites/docs/src/lib/registry/default/ui/calendar bits: https://www.bits-ui.com/docs/components/calendar --- <script> import { ComponentPreview, ManualInstall, Callout, PMAddComp, PMInstall } from '$lib/components/docs'; </script> <ComponentPreview name="calendar-demo"> <div /> </ComponentPreview> ## About The`<Calendar />`component is built on top of the  component, which uses the  package to handle dates. If you're looking for a range calendar, check out the  component. ## Installation <PMAddComp name="calendar" /> <ManualInstall> 1. Install`bits-ui`and`@internationalized/date`: <PMInstall command="bits-ui @internationalized/date" /> 2. Copy and paste the component source files linked at the top of this page into your project. </ManualInstall> ## Date Picker You can use the `<Calendar />`component to build a date picker. See the  page for more information. ## Examples ### Form <ComponentPreview name="date-picker-demo"> <div /> </ComponentPreview> ## Advanced Customization The`<Calendar />`component can be combined with other components to create a more complex calendar. <Callout> By default, we export the combined Calendar component as <code>Calendar</code> as there are quite a few pieces that need to be combined to create it. We're modifying that component in the examples below. </Callout> ### Month & Year Selects Here's an example of how you could create a calendar with month and year select dropdowns instead of the previous and next buttons. <ComponentPreview name="calendar-with-selects"> <div /> </ComponentPreview> --- title: Card description: Displays a card with header, content, and footer. featured: true source: https://github.com/huntabyte/shadcn-svelte/tree/main/sites/docs/src/lib/registry/default/ui/card --- <script> import { ComponentPreview, ManualInstall, PMAddComp } from '$lib/components/docs'; </script> <ComponentPreview name="card-with-form"> <div /> </ComponentPreview> ## Installation <PMAddComp name="card" /> <ManualInstall> 1. Copy and paste the component source files linked at the top of this page into your project. </ManualInstall> ## Usage  ### Modify the heading level By default, the`<Card.Title>`component renders an`<h3>`element. You can change this by passing a`tag`prop to the component. For example:  ...  ## Examples <ComponentPreview name="card-demo"> <div /> </ComponentPreview> --- title: Carousel description: A carousel with motion and swipe built using Embla. component: true source: https://github.com/huntabyte/shadcn-svelte/tree/main/sites/docs/src/lib/registry/default/ui/carousel bits: https://www.embla-carousel.com/get-started/svelte/ --- <script> import { ComponentPreview, ManualInstall, PMAddComp, PMInstall } from '$lib/components/docs'; </script> <ComponentPreview name="carousel-demo"> <div /> </ComponentPreview> ## About The carousel component is built using the  library. ## Installation <PMAddComp name="carousel" /> <ManualInstall> 1. Install`embla-carousel-svelte`: <PMInstall command="embla-carousel-svelte -D" /> 2. Copy and paste the component source files linked at the top of this page into your project. </ManualInstall> ## Usage  ## Examples ### Sizes To set the size of the items, you can use the `basis`utility class on the`<Carousel.Item />`. <ComponentPreview name="carousel-size"> <div /> </ComponentPreview>   ### Spacing To set the spacing between the items, we use a `pl-`utility on the`<Carousel.Item />`and a negative`-ml-`on the`<Carousel.Content />`. <ComponentPreview name="carousel-spacing"> <div /> </ComponentPreview>   ### Orientation Use the `orientation`prop to set the orientation of the carousel. <ComponentPreview name="carousel-orientation"> <div /> </ComponentPreview>  ## Options You can pass options to the carousel using the`opts`prop. See the  for more information.  ## API Use reactive state and the`bind:api`directive to get an instance of the carousel API. <ComponentPreview name="carousel-api"> <div /> </ComponentPreview>  ## Events You can listen to events using the api instance from`bind:api`.  ## Plugins You can use the `plugins`prop to add plugins to the carousel.  <ComponentPreview name="carousel-plugin"> <div /> </ComponentPreview> See the  for more information on using plugins. --- title: Checkbox description: A control that allows the user to toggle between checked and not checked. component: true source: https://github.com/huntabyte/shadcn-svelte/tree/main/sites/docs/src/lib/registry/default/ui/checkbox bits: https://www.bits-ui.com/docs/components/checkbox --- <script> import { ComponentPreview, ManualInstall, PMAddComp, PMInstall } from '$lib/components/docs'; </script> <ComponentPreview name="checkbox-demo"> <div /> </ComponentPreview> ## Installation <PMAddComp name="checkbox" /> <ManualInstall> 1. Install`bits-ui`: <PMInstall command="bits-ui" /> 2. Copy and paste the component source files linked at the top of this page into your project. </ManualInstall> ## Usage   ## Examples ### With Text <ComponentPreview name="checkbox-with-text"> <div /> </ComponentPreview> ### Disabled <ComponentPreview name="checkbox-disabled"> <div /> </ComponentPreview> ### Form <ComponentPreview name="checkbox-form-single"> <div /> </ComponentPreview> <ComponentPreview name="checkbox-form-multiple"> <div /> </ComponentPreview> --- title: Collapsible description: An interactive component which expands/collapses a panel. component: true featured: true source: https://github.com/huntabyte/shadcn-svelte/tree/main/sites/docs/src/lib/registry/default/ui/collapsible bits: https://www.bits-ui.com/docs/components/collapsible --- <script> import { ComponentPreview, ManualInstall, PMAddComp, PMInstall } from '$lib/components/docs'; </script> <ComponentPreview name="collapsible-demo"> <div /> </ComponentPreview> ## Installation <PMAddComp name="collapsible" /> <ManualInstall> 1. Install `bits-ui`: <PMInstall command="bits-ui" /> 2. Copy and paste the component source files linked at the top of this page into your project. </ManualInstall> ## Usage --- title: Combobox description: Autocomplete input and command palette with a list of suggestions. component: true --- <script> import { ComponentPreview, ManualInstall, Callout } from '$lib/components/docs'; </script> <ComponentPreview name="combobox-demo"> <div /> </ComponentPreview> ## Installation The Combobox is built using a composition of the `<Popover />`and the`<Command />`components. See installation instructions for the  and the  components. ## Usage  ## Examples ### Combobox <ComponentPreview name="combobox-demo"> <div /> </ComponentPreview> ### Popover <ComponentPreview name="combobox-popover"> <div /> </ComponentPreview> ### Dropdown menu <ComponentPreview name="combobox-dropdown-menu"> <div /> </ComponentPreview> ### Form Since the Combobox is built using the`<Popover />`and the`<Command />`components, we need to use the`<Form.Control />`component.`<Form.Control />`enables us to apply the right`aria-*`attributes to non-standard form elements, and adds a hidden input to ensure the form is submitted with the correct value. Note: You must be on version`0.5.0`or higher of`formsnap`for this to work correctly. <ComponentPreview name="combobox-form"> <div /> </ComponentPreview> --- title: Command description: Fast, composable, unstyled command menu for Svelte. component: true source: https://github.com/huntabyte/shadcn-svelte/tree/main/sites/docs/src/lib/registry/default/ui/command bits: https://github.com/huntabyte/cmdk-sv --- <script> import { ComponentPreview, ManualInstall, Callout, PMAddComp, PMInstall } from '$lib/components/docs'; </script> <ComponentPreview name="command-demo" align="start" > <div /> </ComponentPreview> ## About The`<Command />`component uses the  library to provide a fast, composable, unstyled command menu for Svelte. <Callout> **Note:**`cmdk-sv`is a new library and is still in alpha. While I don't anticipate a ton of breaking changes, as the API aligns with the original, I want to bring this to your awareness. If you find any bugs, please  with the library, rather than this project. </Callout> ## Installation <PMAddComp name="command" /> <ManualInstall> 1. Install`cmdk-sv`and`bits-ui`: <PMInstall command="cmdk-sv bits-ui" /> 2. Copy and paste the component source files linked at the top of this page into your project. </ManualInstall> ## Usage  ## Examples ### Dialog <ComponentPreview name="command-dialog"> <div /> </ComponentPreview> To show the command menu in a dialog, use the `<Command.Dialog />`component instead of`<Command.Root />`. It accepts props for both the `<Dialog.Root />`and`<Command.Root />`components. --- title: Context Menu description: Displays a menu to the user — such as a set of actions or functions — triggered by right click. component: true source: https://github.com/huntabyte/shadcn-svelte/tree/main/sites/docs/src/lib/registry/default/ui/context-menu bits: https://www.bits-ui.com/docs/components/context-menu --- <script> import { ComponentPreview, ManualInstall, PMAddComp, PMInstall } from '$lib/components/docs' </script> <ComponentPreview name="context-menu-demo"> <div /> </ComponentPreview> ## Installation <PMAddComp name="context-menu" /> <ManualInstall> 1. Install`bits-ui`: <PMInstall command="bits-ui" /> 2. Copy and paste the component source files linked at the top of this page into your project. </ManualInstall> ## Usage --- title: Data Table description: Powerful table and datagrids built using Svelte Headless Table. component: true source: https://github.com/huntabyte/shadcn-svelte/tree/main/sites/docs/src/lib/registry/default/example/data-table-demo.svelte --- <script> import { ComponentPreview, ManualInstall, Callout, Steps, PMAddComp, PMInstall } from '$lib/components/docs' </script> <ComponentPreview name="data-table-demo"> <div /> </ComponentPreview> ## Introduction Data tables are difficult to componentize because of the wide variety of features they support, and the uniqueness of every data set. So instead of trying to create a one-size-fits-all solution, we've created a guide to help you build your own data tables. We'll start with the basic `<Table />`component, and work our way up to a fully-featured data table. <Callout> <strong>Tip:</strong> If you find yourself using the same table in multiple places, you can always extract it into a reusable component. </Callout> ## Table of Contents This guide will show you how to use  and the`<Table />`component to build your own custom data table. We'll cover the following topics: - Basic Table - Row Actions - Pagination - Sorting - Filtering - Visibility - Row Selection - Reusable Components ## Installation 1. Add the`<Table />`component to your project: <PMAddComp name="table" /> 2. Add`svelte-headless-table`as a dependency: <PMInstall command="svelte-headless-table" /> ## Prerequisites We're going to build a table to show recent payments. Here's what our data looks like:  ## Project Structure Start by creating a route where your data table will live , along with the following files:  -`data-table.svelte`will contain the`<Table />`component all of our data table logic. -`data-table-actions.svelte`will contain the actions menu for each row. -`data-table-checkbox.svelte`will contain the checkbox for each row. -`+page.svelte`is where we'll render and access`<DataTable />`component. ## Basic Table Let's start by building a basic table. <Steps> ### Get/Add Data Before we can initialize a table, we need to get our data. You can retrieve your data from anywhere, but for this example we'll use a`payments`array.  ### Initialize Table Next, we'll initialize a new table using`svelte-headless-table`.  ### Create Columns Now that we have a table, we can define our columns.  The last column is where we'll render a menu of actions for each row. ### Create View Model & Render Table Finally, we'll create a view model which we'll use to build our table.  ### Render the table Finally, we'll render our table in our `+page.svelte`file.  </Steps> ## Cell Formatting Now that we have a basic table, let's format the`amount`cell to display the dollar amount. We'll also align the cell to the right. <Steps> ### Update columns definition First, we'll update our columns definition for the`amount`column to return a formatted string.  ### Update styles Now that we're returning a formatted string, let's now align the`amount`header and cell to the right. We'll also capitalize our`status`cell values.  You can use this approach to customize the styles of any cell in your table. In the following sections, we'll demonstrate how you can use a component to render a cell as well. </Steps> ## Row Actions Let's now add row actions to our table. We'll use a`<DropdownMenu />`and`<Button />`component for this. <Steps> ### Create actions component We'll start by creating a new component called`data-table-actions.svelte`which will contain our actions menu. It's going to receive an`id`prop, which we'll use to identify and perform specific actions on the row.  ### Update columns definition Now that we've defined our actions component, let's update our`actions`column definition to use it.  We're just passing the`id`to our actions component, but you could pass whatever information you need to perform actions on the row. In this example, we could use the`id`to make a DELETE request to our API to delete the payment. </Steps> ## Pagination Next, we'll add pagination to our table <Steps> ### Enable the`addPagination`plugin  ### Add pagination controls We can add pagination controls to our table using the`<Button />`component and the`hasNextPage`, `hasPreviousPage`, and `pageIndex`variables.  See the  for more information on how to customize the pagination behavior. </Steps> ## Sorting Let's make the email column sortable. <Steps> ### Enable the`addSortBy`plugin Let's enable the`addSortBy`plugin and import the`<ArrowUpDown />`icon which we'll use to indicate the sort option for the column.  ### Make header cell sortable We can now update the`email`header cell to add sorting controls.  See the  for more information on how to customize the sort behavior. </Steps> ## Filtering Let's add a search input to filter emails in our table. <Steps> ### Enable the`addTableFilter`plugin We'll start by enabling the`addTableFilter`plugin and importing the`<Input />`component we'll use for the search input.  We're excluding all columns except for`email`from the filter plugin, and we're using a case-insensitive filter function to match the email value. ### Add search input Now that our table is configured to filter by email, let's add a search input on top of our table.  Since`filterValue`is a store, we can bind it to the input value and it will automatically update as the user types. See the  for more information on how to customize the filtering behavior. </Steps> ## Visibility Let's add the ability to control which columns are visible in our table. <Steps> ### Enable`addHiddenColumns`plugin We'll start by enabling the`addHiddenColumns`plugin. We'll also need a`<ChevronDown />`icon and the`<DropdownMenu />`component in the next step.  We're setting the`hiddenColumnIds`store from the plugin whenever`hideForId`changes to reflect our newly chosen hidden/shown columns. ### Add column visibility controls Now we'll use the icon and`<DropdownMenu />`we imported in the previous step to render a menu of columns that can be hidden.  See the  for more information. </Steps> ## Row Selection Next, we're going to add row selection to our table. <Steps> ### Create checkbox component We'll start by creating a new component called`data-table-checkbox.svelte`which will be used to render a checkbox for each row.  ### Enable`addSelectedRows`plugin Next, we'll enable the`addSelectedRows`plugin and import the`<Checkbox />`component we just created.  ### Update styles & show selected rows To accommodate the checkbox, we'll need to update our table styles. We'll also add a message to show how many rows are selected.  See the  for more information on how to customize the selection behavior. </Steps> --- title: Date Picker description: A date picker component with range and presets. component: true source: https://github.com/huntabyte/shadcn-svelte/blob/main/sites/docs/src/lib/registry/default/example/date-picker-demo.svelte --- <script> import { ComponentPreview, ManualInstall } from '$lib/components/docs'; </script> <ComponentPreview name="date-picker-demo"> <div /> </ComponentPreview> ## Installation The Date Picker is built using a composition of the`<Popover />`and either the`<Calendar />`or`<RangeCalendar />`components. See installations instructions for the , , and  components. ## Usage  ## Examples ### Date Picker <ComponentPreview name="date-picker-demo"> <div /> </ComponentPreview> ### Date Range Picker <ComponentPreview name="date-picker-with-range"> <div /> </ComponentPreview> ### With Presets <ComponentPreview name="date-picker-with-presets"> <div /> </ComponentPreview> ### Form <ComponentPreview name="date-picker-form"> <div /> </ComponentPreview> --- title: Dialog description: A window overlaid on either the primary window or another dialog window, rendering the content underneath inert. component: true featured: true source: https://github.com/huntabyte/shadcn-svelte/tree/main/sites/docs/src/lib/registry/default/ui/dialog bits: https://www.bits-ui.com/docs/components/dialog --- <script> import { ComponentPreview, ManualInstall, PMAddComp, PMInstall } from '$lib/components/docs'; </script> <ComponentPreview name="dialog-demo"> <div /> </ComponentPreview> ## Installation <PMAddComp name="dialog" /> <ManualInstall> 1. Install`bits-ui`: <PMInstall command="bits-ui" /> 2. Copy and paste the component source files linked at the top of this page into your project. </ManualInstall> ## Usage --- title: Drawer description: A drawer component for Svelte. component: true source: https://github.com/huntabyte/shadcn-svelte/tree/main/sites/docs/src/lib/registry/default/ui/drawer bits: https://www.vaul-svelte.com --- <script> import { ComponentPreview, ManualInstall, PMAddComp, PMInstall } from '$lib/components/docs' </script> <ComponentPreview name="drawer-demo"> <div /> </ComponentPreview> ## About Drawer is built on top of , which is a Svelte port of  by . ## Installation <PMAddComp name="drawer" /> <ManualInstall> 1. Install `vaul-svelte`: <PMInstall command="vaul-svelte" /> 2. Copy and paste the component source files linked at the top of this page into your project. </ManualInstall> ## Usage  ## Examples ### Responsive Dialog You can combine the `Dialog`and`Drawer`components to create a responsive dialog. This renders a`Dialog`on desktop and a`Drawer`on mobile. <ComponentPreview name="drawer-dialog"> <div /> </ComponentPreview> --- title: Dropdown Menu description: Displays a menu to the user — such as a set of actions or functions — triggered by a button. component: true source: https://github.com/huntabyte/shadcn-svelte/tree/main/sites/docs/src/lib/registry/default/ui/dropdown-menu bits: https://www.bits-ui.com/docs/components/dropdown-menu --- <script> import { ComponentPreview, ManualInstall, PMAddComp, PMInstall } from '$lib/components/docs' </script> <ComponentPreview name="dropdown-menu-demo"> <div /> </ComponentPreview> ## Installation <PMAddComp name="dropdown-menu" /> <ManualInstall> 1. Install`bits-ui`: <PMInstall command="bits-ui" /> 2. Copy and paste the component source files linked at the top of this page into your project. </ManualInstall> ## Usage  ## Examples ### Checkboxes <ComponentPreview name="dropdown-menu-checkboxes"> <div /> </ComponentPreview> ### Radio Group <ComponentPreview name="dropdown-menu-radio-group"> <div /> </ComponentPreview> --- title: Formsnap & Superforms description: Building forms with Formsnap, Superforms, & Zod. --- <script> import { Steps, ComponentPreview, FormPreview, PMAddComp, PMInstall } from '$lib/components/docs'; export let form; </script> Forms are tricky. They are one of the most common things you'll build in a web application, but also one of the most complex. Well-designed HTML forms are: - Well-structured and semantically correct. - Easy to use and navigate . - Accessible with ARIA attributes and proper labels. - Has support for client and server side validation. - Well-styled and consistent with the rest of the application. In this guide, we will take a look at building forms with ,  and . ## Features The `Form`components offered by`shadcn-svelte`are wrappers around`formsnap`&`sveltekit-superforms`which provide a few things: - Composable components for building forms. - Form field components for scoping form state. - Form validation using  or any other validation library supported by . - Applies the correct`aria`attributes to form fields based on states. - Enables you to easily use various components like , , ,  and other form components with forms. If you aren't familiar with  & , you should check out their documentation first, as this guide assumes you have a basic understanding of how they work together. ## Anatomy  ## Example  ## Installation <PMAddComp name="form" /> ## Usage <Steps> ### Create a form schema Define the shape of your form using a Zod schema. You can read more about using Zod in the . We're going to define it in a file called`schema.ts`in the same directory as our page component, but you can put it anywhere you like.  ### Return the form from the route's load function  ### Create a form component For this example, we'll be passing the`form`returned from the load function as a prop to this component. To ensure it's typed properly, we'll use the`SuperValidated`type from`sveltekit-superforms`, and pass in the type of our form schema.  The `name`, `id`, and all accessibility attributes are applied to the input by spreading the `attrs`object from the`Form.Control`component. The`Form.Label`will automatically be associated with the input using the`for`attribute, so you don't have to worry about that. ### Create a page component that uses the form We'll pass the`form`from the data returned from the load function to the form component we created above.  ### Create an Action that handles the form submission  ### Done That's it. You now have a fully accessible form that is type-safe and has client & server side validation. <FormPreview {form} /> </Steps> ## Next Steps Be sure to check out the  and  documentation for more information on how to use them. ## Examples See the following links for more examples on how to use the other`Form`components: -  -  -  -  -  -  - --- title: Hover Card description: For sighted users to preview content available behind a link. component: true source: https://github.com/huntabyte/shadcn-svelte/tree/main/sites/docs/src/lib/registry/default/ui/hover-card bits: https://www.bits-ui.com/docs/components/link-preview --- <script> import { ComponentPreview, ManualInstall, PMAddComp, PMInstall } from '$lib/components/docs'; </script> <ComponentPreview name="hover-card-demo"> <div /> </ComponentPreview> ## Installation <PMAddComp name="hover-card" /> <ManualInstall> 1. Install`bits-ui`: <PMInstall command="bits-ui" /> 2. Copy and paste the component source files linked at the top of this page into your project. </ManualInstall> ## Usage --- title: Input description: Displays a form input field or a component that looks like an input field. component: true source: https://github.com/huntabyte/shadcn-svelte/tree/main/sites/docs/src/lib/registry/default/ui/input --- <script> import { ComponentPreview, ManualInstall, PMAddComp} from '$lib/components/docs'; export let form; </script> <ComponentPreview name="input-demo"> <div /> </ComponentPreview> ## Installation <PMAddComp name="input" /> <ManualInstall> 1. Copy and paste the component source files linked at the top of this page into your project. </ManualInstall> ## Usage  ## Examples ### Default <ComponentPreview name="input-demo"> <div /> </ComponentPreview> ### Disabled <ComponentPreview name="input-disabled"> <div /> </ComponentPreview> ### With Label <ComponentPreview name="input-with-label"> <div /> </ComponentPreview> ### With Text <ComponentPreview name="input-with-text"> <div /> </ComponentPreview> ### With Button <ComponentPreview name="input-with-button"> <div /> </ComponentPreview> ### File <ComponentPreview name="input-file"> <div /> </ComponentPreview> ### Form <ComponentPreview name="form-demo" {form}> <div /> </ComponentPreview> --- title: Label description: Renders an accessible label associated with controls. component: true source: https://github.com/huntabyte/shadcn-svelte/tree/main/sites/docs/src/lib/registry/default/ui/label bits: https://www.bits-ui.com/docs/components/label --- <script> import { ComponentPreview, ManualInstall, PMAddComp, PMInstall } from '$lib/components/docs'; </script> <ComponentPreview name="label-demo"> <div /> </ComponentPreview> ## Installation <PMAddComp name="label" /> <ManualInstall> 1. Install `bits-ui`: <PMInstall command="bits-ui" /> 2. Copy and paste the component source files linked at the top of this page into your project. </ManualInstall> ## Usage --- title: Menubar description: A visually persistent menu common in desktop applications that provides quick access to a consistent set of commands. component: true source: https://github.com/huntabyte/shadcn-svelte/tree/main/sites/docs/src/lib/registry/default/ui/menubar bits: https://www.bits-ui.com/docs/components/menubar --- <script> import { ComponentPreview, ManualInstall, PMAddComp, PMInstall } from '$lib/components/docs' </script> <ComponentPreview name="menubar-demo"> </ComponentPreview> ## Installation <PMAddComp name="menubar" /> <ManualInstall> 1. Install `bits-ui`: <PMInstall command="bits-ui" /> 2. Copy and paste the component source files linked at the top of this page into your project. </ManualInstall> ## Usage --- title: Pagination description: Pagination with page navigation, next and previous links. component: true source: https://github.com/huntabyte/shadcn-svelte/tree/main/sites/docs/src/lib/registry/default/ui/pagination bits: https://www.bits-ui.com/docs/components/pagination --- <script> import { ComponentPreview, ManualInstall, PMAddComp, PMInstall } from '$lib/components/docs'; </script> <ComponentPreview name="pagination-demo" > <div /> </ComponentPreview> ## Installation <PMAddComp name="pagination" /> <ManualInstall> 1. Install `bits-ui`: <PMInstall command="bits-ui" /> 2. Copy and paste the component source files linked at the top of this page into your project. </ManualInstall> ## Usage --- title: Popover description: Displays rich content in a portal, triggered by a button. component: true source: https://github.com/huntabyte/shadcn-svelte/tree/main/sites/docs/src/lib/registry/default/ui/popover bits: https://www.bits-ui.com/docs/components/popover --- <script> import { ComponentPreview, ManualInstall, PMAddComp, PMInstall } from '$lib/components/docs'; </script> <ComponentPreview name="popover-demo"> <div /> </ComponentPreview> ## Installation <PMAddComp name="popover" /> <ManualInstall> 1. Install `bits-ui`: <PMInstall command="bits-ui" /> 2. Copy and paste the component source files linked at the top of this page into your project. </ManualInstall> ## Usage --- title: Progress description: Displays an indicator showing the completion progress of a task, typically displayed as a progress bar. component: true source: https://github.com/huntabyte/shadcn-svelte/tree/main/sites/docs/src/lib/registry/default/ui/progress bits: https://www.bits-ui.com/docs/components/progress --- <script> import { ComponentPreview, ManualInstall, PMAddComp, PMInstall } from '$lib/components/docs'; </script> <ComponentPreview name="progress-demo"> <div /> </ComponentPreview> ## Installation <PMAddComp name="progress" /> <ManualInstall> 1. Install `bits-ui`: <PMInstall command="bits-ui" /> 2. Copy and paste the component source files linked at the top of this page into your project. </ManualInstall> ## Usage --- title: Radio Group description: A set of checkable buttons—known as radio buttons—where no more than one of the buttons can be checked at a time. component: true source: https://github.com/huntabyte/shadcn-svelte/tree/main/sites/docs/src/lib/registry/default/ui/radio-group bits: https://www.bits-ui.com/docs/components/radio-group --- <script> import { ComponentPreview, ManualInstall, PMAddComp, PMInstall } from '$lib/components/docs'; </script> <ComponentPreview name="radio-group-demo"> <div /> </ComponentPreview> ## Installation <PMAddComp name="radio-group" /> <ManualInstall> 1. Install `bits-ui`: <PMInstall command="bits-ui" /> 2. Copy and paste the component source files linked at the top of this page into your project. </ManualInstall> ## Usage  ## Examples ### Form <ComponentPreview name="radio-group-form"> <div /> </ComponentPreview> --- title: Range Calendar description: A calendar component that allows users to select a range of dates. component: true source: https://github.com/huntabyte/shadcn-svelte/tree/main/sites/docs/src/lib/registry/default/ui/range-calendar bits: https://www.bits-ui.com/docs/components/range-calendar --- <script> import { ComponentPreview, ManualInstall, PMAddComp, PMInstall } from '$lib/components/docs'; </script> <ComponentPreview name="range-calendar-demo"> <div /> </ComponentPreview> ## About The `<RangeCalendar />`component is built on top of the  component, which uses the  package to handle dates. ## Installation <PMAddComp name="range-calendar" /> <ManualInstall> 1. Install`bits-ui`and`@internationalized/date`: <PMInstall command="bits-ui @internationalized/date" /> 2. Copy and paste the component source files linked at the top of this page into your project. </ManualInstall> --- title: Resizable description: Accessible resizable panel groups and layouts with keyboard support. component: true source: https://github.com/huntabyte/shadcn-svelte/tree/main/sites/docs/src/lib/registry/default/ui/resizable bits: https://paneforge.com --- <script> import { ComponentPreview, ManualInstall, PMAddComp, PMInstall } from '$lib/components/docs' </script> <ComponentPreview name="resizable-demo"> <div /> </ComponentPreview> ## About The `Resizable`component is built on top of  by . Visit the  for all the available props and abilities of the`Resizable`component. ## Installation <PMAddComp name="resizable" /> <ManualInstall> 1. Install`paneforge`: <PMInstall command="paneforge" /> 2. Copy and paste the component source files linked at the top of this page into your project. </ManualInstall> ## Usage  ## Examples ### Vertical Use the `direction`prop to set the direction of the resizable panels. <ComponentPreview name="resizable-vertical"> <div /> </ComponentPreview>  ### Handle You can set or hide the handle by using the`withHandle`prop on the`ResizableHandle`component. <ComponentPreview name="resizable-handle"> <div /> </ComponentPreview> --- title: Scroll Area description: Augments native scroll functionality for custom, cross-browser styling. component: true source: https://github.com/huntabyte/shadcn-svelte/tree/main/sites/docs/src/lib/registry/default/ui/scroll-area bits: https://bits-ui.com/docs/components/scroll-area --- <script> import { ComponentPreview, ManualInstall, PMAddComp, PMInstall } from '$lib/components/docs'; </script> <ComponentPreview name="scroll-area-demo"> <div /> </ComponentPreview> ## Installation <PMAddComp name="scroll-area" /> <ManualInstall> 1. Install`bits-ui`: <PMInstall command="bits-ui" /> 2. Copy and paste the component source files linked at the top of this page into your project. </ManualInstall> ## Usage  ## Examples ### Horizontal Scrolling Set the `orientation`prop to`"horizontal"`to enable horizontal scrolling. <ComponentPreview name="scroll-area-horizontal"> <div /> </ComponentPreview> ### Horizontal and Vertical Scrolling Set the`orientation`prop to`"both"`to enable both horizontal and vertical scrolling. <ComponentPreview name="scroll-area-both"> <div /> </ComponentPreview> --- title: Select description: Displays a list of options for the user to pick from—triggered by a button. component: true source: https://github.com/huntabyte/shadcn-svelte/tree/main/sites/docs/src/lib/registry/default/ui/select bits: https://www.bits-ui.com/docs/components/select --- <script> import { ComponentPreview, ManualInstall, PMAddComp, PMInstall } from '$lib/components/docs' </script> <ComponentPreview name="select-demo"> <div /> </ComponentPreview> ## Installation <PMAddComp name="select" /> <ManualInstall> 1. Install`bits-ui`: <PMInstall command="bits-ui" /> 2. Copy and paste the component source files linked at the top of this page into your project. </ManualInstall> ## Usage  ## Examples ### Form For more advanced usage and to learn how to implement `multiple`Select components in a form, check out the  on Formsnap. <ComponentPreview name="select-form"> <div /> </ComponentPreview> --- title: Separator description: Visually or semantically separates content. component: true source: https://github.com/huntabyte/shadcn-svelte/tree/main/sites/docs/src/lib/registry/default/ui/separator bits: https://www.bits-ui.com/docs/components/separator --- <script> import { ComponentPreview, ManualInstall, PMAddComp, PMInstall } from '$lib/components/docs'; </script> <ComponentPreview name="separator-demo"> <div /> </ComponentPreview> ## Installation <PMAddComp name="separator" /> <ManualInstall> 1. Install`bits-ui`: <PMInstall command="bits-ui" /> 2. Copy and paste the component source files linked at the top of this page into your project. </ManualInstall> ## Usage --- title: Sheet description: Extends the Dialog component to display content that complements the main content of the screen. component: true source: https://github.com/huntabyte/shadcn-svelte/tree/main/sites/docs/src/lib/registry/default/ui/sheet bits: https://www.bits-ui.com/docs/components/dialog --- <script> import { ComponentPreview, ManualInstall, PMAddComp, PMInstall } from '$lib/components/docs'; </script> <ComponentPreview name="sheet-demo"> <div /> </ComponentPreview> ## Installation <PMAddComp name="sheet" /> <ManualInstall> 1. Install `bits-ui`: <PMInstall command="bits-ui" /> 2. Copy and paste the component source files linked at the top of this page into your project. </ManualInstall> ## Usage  ## Examples ### Side Pass the `side`property to`<SheetContent />`to indicate the edge of the screen where the component will appear. The values can be`top`, `right`, `bottom`or`left`. <ComponentPreview name="sheet-side"> <div /> </ComponentPreview> --- title: Skeleton description: Use to show a placeholder while content is loading. component: true source: https://github.com/huntabyte/shadcn-svelte/tree/main/sites/docs/src/lib/registry/default/ui/skeleton --- <script> import { ComponentPreview, ManualInstall, PMAddComp, PMInstall } from '$lib/components/docs'; </script> <ComponentPreview name="skeleton-demo"> <div /> </ComponentPreview> ## Installation <PMAddComp name="skeleton" /> <ManualInstall> 1. Copy and paste the component source files linked at the top of this page into your project. </ManualInstall> ## Usage --- title: Slider description: An input where the user selects a value from within a given range. component: true source: https://github.com/huntabyte/shadcn-svelte/tree/main/sites/docs/src/lib/registry/default/ui/slider bits: https://www.bits-ui.com/docs/components/slider --- <script> import { ComponentPreview, ManualInstall, PMAddComp, PMInstall } from '$lib/components/docs'; </script> <ComponentPreview name="slider-demo"> <div /> </ComponentPreview> ## Installation <PMAddComp name="slider" /> <ManualInstall> 1. Install `bits-ui`: <PMInstall command="bits-ui" /> 2. Copy and paste the component source files linked at the top of this page into your project. </ManualInstall> ## Usage --- title: Sonner description: An opinionated toast component for Svelte. component: true source: https://github.com/huntabyte/shadcn-svelte/tree/main/sites/docs/src/lib/registry/default/ui/sonner --- <script> import { ComponentPreview, ManualInstall, Steps, Step, PMAddComp, PMInstall } from '$lib/components/docs'; </script> <ComponentPreview name="sonner-demo"> <div /> </ComponentPreview> ## About The Sonner component is provided by , which is a Svelte port of , originally created by  for React. ## Installation <Steps> <Step> Setup theme support </Step> By default, Sonner will use the user's system preferences to determine whether to show the light or dark theme. To get around this, you can either pass in a custom `theme`prop to the component, or simply use  which you can hardcode to`dark`or`light`mode should you wish. You can learn more about setting up Dark Mode support . If you wish to opt out of Dark Mode support, you can uninstall`mode-watcher`and remove the`theme`prop from the component after installing via CLI, or manually install the component and don't include`mode-watcher`<Step> Run the following command: </Step> <PMAddComp name="sonner" /> <Step> Add the Toaster component </Step> Note: Make sure you are adding the import from the path`"$lib/components/ui/sonner"` not `"svelte-sonner"`.  </Steps> <ManualInstall> 1. Install `svelte-sonner`: <PMInstall command="svelte-sonner" /> 2. Copy and paste the component source files linked at the top of this page into your project. </ManualInstall> ## Usage --- title: Switch description: A control that allows the user to toggle between checked and not checked. component: true source: https://github.com/huntabyte/shadcn-svelte/tree/main/sites/docs/src/lib/registry/default/ui/switch bits: https://www.bits-ui.com/docs/components/switch --- <script> import { ComponentPreview, ManualInstall, PMAddComp, PMInstall } from '$lib/components/docs'; </script> <ComponentPreview name="switch-demo"> <div /> </ComponentPreview> ## Installation <PMAddComp name="switch" /> <ManualInstall> 1. Install `bits-ui`: <PMInstall command="bits-ui" /> 2. Copy and paste the component source files linked at the top of this page into your project. </ManualInstall> ## Usage ## Examples ### Form <ComponentPreview name="switch-form"> <div /> </ComponentPreview> --- title: Table description: A responsive table component. component: true source: https://github.com/huntabyte/shadcn-svelte/tree/main/sites/docs/src/lib/registry/default/ui/table --- <script> import { ComponentPreview, ManualInstall, PMAddComp } from '$lib/components/docs'; </script> <ComponentPreview name="table-demo"> <div /> </ComponentPreview> ## Installation <PMAddComp name="table" /> <ManualInstall> 1. Copy and paste the component source files linked at the top of this page into your project. </ManualInstall> ## Usage --- title: Tabs description: A set of layered sections of content—known as tab panels—that are displayed one at a time. component: true source: https://github.com/huntabyte/shadcn-svelte/tree/main/sites/docs/src/lib/registry/default/ui/tabs bits: https://www.bits-ui.com/docs/components/tabs --- <script> import { ComponentPreview, ManualInstall, PMAddComp, PMInstall } from '$lib/components/docs'; </script> <ComponentPreview name="tabs-demo"> <div /> </ComponentPreview> ## Installation <PMAddComp name="tabs" /> <ManualInstall> 1. Install `bits-ui`: <PMInstall command="bits-ui" /> 2. Copy and paste the component source files linked at the top of this page into your project. </ManualInstall> ## Usage --- title: Textarea description: Displays a form textarea or a component that looks like a textarea. component: true source: https://github.com/huntabyte/shadcn-svelte/tree/main/sites/docs/src/lib/registry/default/ui/textarea --- <script> import { ComponentPreview, ManualInstall, PMAddComp } from '$lib/components/docs'; </script> <ComponentPreview name="textarea-demo"> <div /> </ComponentPreview> ## Installation <PMAddComp name="textarea" /> <ManualInstall> 1. Copy and paste the component source files linked at the top of this page into your project. </ManualInstall> ## Usage   ## Examples ### Default <ComponentPreview name="textarea-demo"> <div /> </ComponentPreview> ### Disabled <ComponentPreview name="textarea-disabled"> <div /> </ComponentPreview> ### With Label <ComponentPreview name="textarea-with-label"> <div /> </ComponentPreview> ### With Text <ComponentPreview name="textarea-with-text"> <div /> </ComponentPreview> ### With Button <ComponentPreview name="textarea-with-button"> <div /> </ComponentPreview> ### Form <ComponentPreview name="textarea-form"> <div /> </ComponentPreview> --- title: Toggle Group description: A set of two-state buttons that can be toggled on or off. component: true source: https://github.com/huntabyte/shadcn-svelte/tree/main/sites/docs/src/lib/registry/default/ui/toggle-group bits: https://www.bits-ui.com/docs/components/toggle-group --- <script> import { ComponentPreview, ManualInstall, PMAddComp, PMInstall } from '$lib/components/docs'; </script> <ComponentPreview name="toggle-group-demo"> <div /> </ComponentPreview> ## Installation <PMAddComp name="toggle-group" /> <ManualInstall> 1. Install `bits-ui`: <PMInstall command="bits-ui" /> 2. Copy and paste the component source files linked at the top of this page into your project. </ManualInstall> ## Usage ## Examples ### Default <ComponentPreview name="toggle-group-demo"> <div /> </ComponentPreview> ### Outline <ComponentPreview name="toggle-group-outline"> <div /> </ComponentPreview> ### Single <ComponentPreview name="toggle-group-single"> <div /> </ComponentPreview> ### Small <ComponentPreview name="toggle-group-sm"> <div /> </ComponentPreview> ### Large <ComponentPreview name="toggle-group-lg"> <div /> </ComponentPreview> ### Disabled <ComponentPreview name="toggle-group-disabled"> <div /> </ComponentPreview> --- title: Toggle description: A two-state button that can be either on or off. component: true source: https://github.com/huntabyte/shadcn-svelte/tree/main/sites/docs/src/lib/registry/default/ui/toggle bits: https://www.bits-ui.com/docs/components/toggle --- <script> import { ComponentPreview, ManualInstall, PMAddComp, PMInstall } from '$lib/components/docs'; </script> <ComponentPreview name="toggle-demo"> <div /> </ComponentPreview> ## Installation <PMAddComp name="toggle" /> <ManualInstall> 1. Install `bits-ui`: <PMInstall command="bits-ui" /> 2. Copy and paste the component source files linked at the top of this page into your project. </ManualInstall> ## Usage  ## Examples ### Default <ComponentPreview name="toggle-demo"> <div /> </ComponentPreview> ### Outline <ComponentPreview name="toggle-outline"> <div /> </ComponentPreview> ### With Text <ComponentPreview name="toggle-with-text"> <div /> </ComponentPreview> ### Small <ComponentPreview name="toggle-sm"> <div /> </ComponentPreview> ### Large <ComponentPreview name="toggle-lg"> <div /> </ComponentPreview> ### Disabled <ComponentPreview name="toggle-disabled"> <div /> </ComponentPreview> --- title: Tooltip description: A popup that displays information related to an element when the element receives keyboard focus or the mouse hovers over it. component: true source: https://github.com/huntabyte/shadcn-svelte/tree/main/sites/docs/src/lib/registry/default/ui/tooltip bits: https://www.bits-ui.com/docs/components/tooltip --- <script> import { ComponentPreview, ManualInstall, PMAddComp, PMInstall } from '$lib/components/docs'; </script> <ComponentPreview name="tooltip-demo"> <div /> </ComponentPreview> ## Installation <PMAddComp name="tooltip" /> <ManualInstall> 1. Install `bits-ui`: <PMInstall command="bits-ui" /> 2. Copy and paste the component source files linked at the top of this page into your project. </ManualInstall> ## Usage --- title: Dark mode on Astro description: Adding dark mode to your Astro site. --- <script> import { Steps, ComponentPreview, PMInstall } from "$lib/components/docs"; </script> Just like in regular Svelte, we use the `class` strategy from Tailwind CSS to support dark mode toggling. See the  for more information. How you add the `dark` class to the `html` element is up to you. In this guide, we'll take a look at enabling dark mode toggling with . ## Usage <Steps> ### Create an inline theme script This script will, in part, keep and track the dark mode value in `localStorage` and prevent .  ### Install mode-watcher <PMInstall command="mode-watcher@0.5.1" /> ### Add the ModeWatcher component Import the `ModeWatcher` component and use it in your page with the `client:load` directive:  ### Create a mode toggle Create a mode toggle on your site to toggle between light and dark mode: #### Light switch <ComponentPreview name="dark-mode-light-switch"> <div /> </ComponentPreview> #### Dropdown menu <ComponentPreview name="dark-mode-dropdown-menu"> <div /> </ComponentPreview> ### Add mode toggle to page Add the mode toggle to the page :  </Steps> --- title: Dark mode description: Adding dark mode to your site. --- <script> import { LinkedCard } from '$lib/components/docs' </script> <div class="grid sm:grid-cols-2 gap-4 mt-8 sm:gap-6"> <LinkedCard href="/docs/dark-mode/svelte"> <p class="font-medium text-xl">Svelte</p> </LinkedCard> <LinkedCard href="/docs/dark-mode/astro"> <p class="font-medium text-xl">Astro</p> </LinkedCard> </div> --- title: Dark mode description: Adding dark mode to your Svelte site. --- <script> import { Steps, ComponentPreview, PMInstall } from "$lib/components/docs"; </script> We use the `class` strategy from Tailwind CSS to support dark mode toggling. See the  for more information. How you add the ` dark` class to the `html` element is up to you. In this guide, we will take a look at enabling dark mode toggling with . ## Usage <Steps> ### Install mode-watcher Start by installing `mode-watcher`: <PMInstall command="mode-watcher@0.5.1" /> ### Add the ModeWatcher component Import the `ModeWatcher` component and use it in your root layout:  ### Add a mode toggle Place a mode toggle on your site to toggle between light and dark mode. #### Light switch <ComponentPreview name="dark-mode-light-switch"> <div /> </ComponentPreview> #### Dropdown menu <ComponentPreview name="dark-mode-dropdown-menu"> <div /> </ComponentPreview> </Steps> --- title: Figma description: Every component recreated in Figma. With customizable props, typography and icons. --- <script> import { AspectRatio } from '$lib/registry/new-york/ui/aspect-ratio'; </script> The Figma UI Kit is open sourced by . <AspectRatio ratio={16 / 9} class="w-full mt-4"> <iframe title="Figma page for shadcn" src="https://embed.figma.com/file/1203061493325953101/hf_embed?community_viewer=true&embed_host=shadcn&hub_file_id=1203061493325953101&kind=&viewer=1" class="h-full w-full overflow-hidden rounded-lg border bg-muted" /> </AspectRatio> ## Grab a copy https://www.figma.com/community/file/1203061493325953101 --- title: Introduction description: Re-usable components built with Bits UI, Melt UI, and Tailwind CSS. --- <script> import _ as Accordion from '$lib/registry/new-york/ui/accordion'; import { Callout } from '$lib/components/docs'; import CircleAlert from "lucide-svelte/icons/circle-alert"; </script> An unofficial, community-led port of . We are not affiliated with , but we did get his blessing before creating a Svelte version of his work. This project was born out of the need for a similar project for the Svelte ecosystem. This is **NOT** a component library. It's a collection of re-usable components that you can copy and paste or use the CLI to add to your apps. **What do you mean not a component library?** It means you do not install it as a dependency. It is not available or distributed via npm, with no plans to publish it. Pick the components you need. Use the CLI to automatically add the components, or copy and paste the code into your project and customize to your needs. The code is yours. \_Use this as a reference to build your own component libraries._ ## FAQ <Accordion.Root multiple> <Accordion.Item value="faq-1"> <Accordion.Trigger> Why not packaged as a dependency? </Accordion.Trigger> <Accordion.Content> The idea behind this is to give you ownership and control over the code, allowing you to decide how the components are built and styled. Start with some sensible defaults, then customize the components to your needs. One of the drawback of packaging the components in an npm package is that the style is coupled with the implementation. _The design of your components should be separate from their implementation._ </Accordion.Content> </Accordion.Item> <Accordion.Item value="faq-2"> <Accordion.Trigger> Which frameworks are supported? </Accordion.Trigger> <Accordion.Content> This port is built to be used with Svelte/SvelteKit. </Accordion.Content> </Accordion.Item> <Accordion.Item value="faq-3"> <Accordion.Trigger> Can I use this in my project? </Accordion.Trigger> <Accordion.Content> Yes. Free to use for personal and commercial projects. No attribution required. But let us know if you do use it. We'd love to see what you build with it. </Accordion.Content> </Accordion.Item> </Accordion.Root> --- title: Astro description: How to setup shadcn-svelte in an Astro project. --- <script> import { Alert, AlertDescription } from "$lib/registry/new-york/ui/alert"; import { Steps, Callout, PMCreate, PMExecute, PMInstall, PMAddComp } from "$lib/components/docs"; </script> ## Setup your project <Steps> ### Create project Start by creating a new Astro project: <PMCreate command="astro@latest" /> ### Configure your Astro project You will be asked a few questions to configure your project: ### Add Svelte to your project Install Svelte using the Astro CLI: <PMExecute command="astro add svelte" /> <Callout className="mt-4"> Answer `Yes` to all the question prompted by the CLI when installing Svelte. </Callout> ### Add TailwindCSS to your project Add Tailwind CSS using the Astro CLI: <PMExecute command="astro add tailwind" /> <Callout className="mt-4"> Answer `Yes` to all the question prompted by the CLI when installing Svelte. </Callout> ### Setup path aliases Add the following code to the `tsconfig.json` file to resolve paths: <Callout className="mt-4"> If needed, adapt the path aliases to your specific needs &#41;. </Callout> ### Create a global CSS file Create the global stylesheet in `src/styles/app.css`: ### Import the global CSS file Import the `app.css` file in the `src/pages/index.astro` file: ### Run the CLI Run the `shadcn-svelte` init command to setup your project: <PMExecute command="shadcn-svelte@latest init" /> ### Configure components.json You will be asked a few questions to configure `components.json`: ### Update Astro's Tailwind config To prevent serving the Tailwind base styles twice, we need to tell Astro not to apply the base styles, since we already include them in our own `app.css` file. To do this, set the `applyBaseStyles` config option for the tailwind plugin in `astro.config.mjs` to `false`. ### Update tailwind.config.mjs When running `shadcn-svelte@latest init`, your Tailwind config for content will be overwritten. To fix this, add `astro` as one of the options inside of `content`: ### That's it You can now start adding components to your project. <PMAddComp name="button" /> The command above will add the `Button` component to your project. You can then import it like this: <Callout className="mt-4"> Remember to use the `client` directives inside `.astro` files when dealing with interactive components &#41;. </Callout> </Steps> --- title: Installation description: How to install dependencies and structure your app. --- <script> import { LinkedCard } from '$lib/components/docs' </script> ## Guides <div class="grid sm:grid-cols-2 gap-4 mt-8 sm:gap-6"> <LinkedCard href="/docs/installation/sveltekit"> <p class="font-medium text-xl">SvelteKit</p> </LinkedCard> <LinkedCard href="/docs/installation/astro"> <p class="font-medium text-xl">Astro</p> </LinkedCard> <LinkedCard href="/docs/installation/vite"> <p class="font-medium text-xl">Vite</p> </LinkedCard> <LinkedCard href="/docs/installation/manual"> <p class="font-medium text-xl">Manual</p> </LinkedCard> </div> ## Imports Unlike the original  for React, where the full components can exist in a single file, components in this port are split into multiple files. This is because Svelte doesn't support defining multiple components in a single file, so utilizing the CLI to add components will be the optimal approach. The CLI will create a folder for _each_ component, which will sometimes just contain a single Svelte file, and in other times, multiple files. Within each folder, there will be an `index.ts` file that exports the component, so you can import them from a single file. For example, the Accordion component is split into four `.svelte` files: - `Accordion.svelte` - `AccordionContent.svelte` - `AccordionItem.svelte` - `AccordionTrigger.svelte` They can then be imported from the `accordion/index.ts` file like so:  Regardless of the import approach you take, the components will be tree-shaken by Rollup, so you don't have to worry about unused components being bundled into your app. ## TypeScript This project and the components are written in TypeScript. We recommend using TypeScript for your project as well. However, we provide a JavaScript version of the components as well. The JavaScript version is _only_ available via the . ### Opt-out of TypeScript To opt out of TypeScript, set the `typescript` flag to `false` in your `components.json` file.  To configure import aliases, create a `jsconfig.json` file:  ## ESLint configuration If you are using ESLint, some components may trigger false positives depending on your ESLint configuration. For example, you could end up with lint errors when components define `$$Props` to specify the type for `$$restProps` as `$$Props` is not directly used in the rest of the component. To ignore these linting errors, you can modify your ESLint configuration. One option is to add a `.eslintrc` file in the directory where you define your components, `$lib/components/ui`for example:  The main benefit of adding an additional`.eslintrc`file just to`$lib/components/ui` is that you will not affect how ESLint functions for the rest of your project. Only your `shadcn-svelte` components will ignore these false positives. If this is not important to you, then another option is to use a similar rule override in your global ESLint configuration file, usually `.eslintrc.cjs`. For inspiration, please refer to . If your global ESLint configuration is using the  or you would like to migrate to the flat config format  you could add another rule block in your `eslint.config.js` for example:  ## VSCode extension Install the shadcn-svelte  by  in Visual Studio Code to easily add Shadcn Svelte components to your project. This extension offers a range of features: - Ability to initialize the shadcn-svelte CLI - Add components to your project - Navigate to a specific component's documentation page directly from your IDE - Handy snippets for quick component imports and markup ## JetBrains IDEs extension Install the shadcn/ui Components Manager  by  in any JetBrains IDE  to easily manage shadcn components within your project. This extension offers a range of features, including: - Automatically detect shadcn/ui components in your project - Instantly add, remove, and update them with a single click - Supports all shadcn/ui implementations: Svelte, React, Vue, and Solid - Easily search for remote or existing components --- title: Manual Installation description: How to setup shadcn-svelte manually. --- <script> import { Steps, Step, PMAddComp, PMInstall, PMExecute } from '$lib/components/docs' </script> ## Setup your project <Steps> ### Add Tailwind Use the Svelte CLI to add Tailwind CSS to your project. <PMExecute command="sv@0.6.18 add tailwindcss" /> ### Add dependencies Add the following dependencies to your project: <PMInstall command="tailwind-variants clsx tailwind-merge" /> ### Add icon library If you're using the `default` style, install `lucide-svelte`: <PMInstall command="lucide-svelte" /> If you're using the `new-york` style, install `svelte-radix`: <PMInstall command="svelte-radix" /> ### Configure path aliases If you are using SvelteKit and are not using the default alias `$lib`, you'll need to update your `svelte.config.js` file to include those aliases. If you are _not_ using SvelteKit, then you'll need to update your path aliases in your `tsconfig.json` and `vite.config.ts`. ### Configure tailwind.config.js This is what this project's `tailwind.config.js` file looks like: Feel free to add or modify as needed to suit your project. ### Configure styles Add the following to your `src/app.pcss` file. You can learn more about using CSS variables for theming in the . ### Configure utils You'll want to create a `cn` helper to make it easier to conditionally add Tailwind CSS classes. Additionally, you'll want to add the custom transition that is used by various components. ### Import styles to your app Create `src/routes/+layout.svelte` and import the styles: ### That's it You can now start adding components to your project. <PMAddComp name="button" /> </Steps> --- title: SvelteKit description: How to setup shadcn-svelte in a SvelteKit project. --- <script> import { Alert, AlertDescription } from "$lib/registry/new-york/ui/alert"; import { Steps, PMCreate, PMExecute, PMInstall, PMAddComp } from "$lib/components/docs"; </script> ## Setup your project <Steps> ### Create project Use the SvelteKit CLI to create a new project. <PMCreate command="svelte@latest my-app" /> ### Add TailwindCSS Use the Svelte CLI to add Tailwind CSS to your project. <PMExecute command="sv@0.6.18 add tailwindcss" /> ### Setup path aliases If you are not using the default alias `$lib`, you'll need to update your `svelte.config.js` file to include those aliases. ### Run the CLI <PMExecute command="shadcn-svelte@latest init" /> ### Configure components.json You will be asked a few questions to configure `components.json`: ### That's it You can now start adding components to your project. <PMAddComp name="button" /> The command above will add the `Button` component to your project. You can then import it like this: </Steps> --- title: Vite description: How to setup shadcn-svelte in a Vite project. --- <script> import { Alert, AlertDescription } from "$lib/registry/new-york/ui/alert"; import { Steps, PMAddComp, PMInstall, PMExecute } from "$lib/components/docs"; </script> ## Setup your project <Steps> ### Add TailwindCSS Use the Svelte CLI to add Tailwind CSS to your project. <PMExecute command="sv@0.6.18 add tailwindcss" /> ### Setup path aliases Update your path aliases in your `tsconfig.json` and `vite.config.ts`. ### Run the CLI <PMExecute command="shadcn-svelte@latest init" /> ### Configure components.json You will be asked a few questions to configure `components.json`: ### That's it You can now start adding components to your project. <PMAddComp name="button" /> The command above will add the `Button` component to your project. You can then import it like this: </Steps> --- title: Theming description: Use CSS Variables to customize the look and feel of your application. --- <script> import { Callout, HexToChannels } from '$lib/components/docs'; </script> We use CSS variables for styling. This allows you to easily change the colors of components without having to update class names. **CSS variables must be defined without the color space function**. See the  for more information. ## Hex -> Color Channel You can use this tool to convert your HEX color to HSL without the color space function. Simply add your color in hex format, copy one of the generated values, then add them to the CSS variable. <HexToChannels /> ## Convention We use a simple `background` and `foreground` convention for colors. The `background` variable is used for the background color of the component and the `foreground` variable is used for the text color. <Callout> The `background` suffix can be omitted if the variable is used for the background color of the component. </Callout> Given the following CSS variables:  The `background` color of the following component will be `hsl / <alpha-value>&#41;` and the `foreground` color will be `hsl / <alpha-value>&#41;`.  ## CSS Variables Here's the list of variables available for customization:             ## Default The following is the default color palette used by the components. --- title: Typography description: Styles for headings, paragraphs, lists...etc component: true --- <script> import { ComponentPreview } from "$lib/components/docs" </script> <ComponentPreview name="typography-demo"> <div/> </ComponentPreview> ## h1 <ComponentPreview name="typography-h1"> <div/> </ComponentPreview> ## h2 <ComponentPreview name="typography-h2"> <div/> </ComponentPreview> ## h3 <ComponentPreview name="typography-h3"> <div/> </ComponentPreview> ## h4 <ComponentPreview name="typography-h4"> <div/> </ComponentPreview> ## p <ComponentPreview name="typography-p"> <div/> </ComponentPreview> ## blockquote <ComponentPreview name="typography-blockquote"> <div/> </ComponentPreview> ## table <ComponentPreview name="typography-table"> <div/> </ComponentPreview> ## list <ComponentPreview name="typography-list"> <div/> </ComponentPreview> ## Inline code <ComponentPreview name="typography-inline-code"> <div/> </ComponentPreview> ## Lead <ComponentPreview name="typography-lead"> <div/> </ComponentPreview> ## Large <ComponentPreview name="typography-large"> <div/> </ComponentPreview> ## Small <ComponentPreview name="typography-small"> <div/> </ComponentPreview> ## Muted <ComponentPreview name="typography-muted"> <div/> </ComponentPreview>)

[//]: # ()
[//]: # (# User coding preferences)

[//]: # ()
[//]: # (- Components that need nested component inside of it must be imported using `import * as Carousel from '$lib/components/ui/carousel'` syntax, like Carousel, Dialog, Card, Tab, etc. All basic components like Button, Input, etc. can be imported using `import { Button } from '$lib/components/ui/button'` syntax.)

[//]: # ()
[//]: # (- For icons use Lucide Svelte, import them using `import { IconName } from 'lucide-svelte'` syntax.)

[//]: # ()
[//]: # (- Events syntax like `on:click` is deprecated, use `onclick` instead. This is valid for all events since Svelte 5 major release.)

[//]: # ()
[//]: # (# User prompt response preferences)

[//]: # ()
[//]: # (- Use the latest version of Svelte and SvelteKit.)

[//]: # ()
[//]: # (- Use the latest version of Tailwind CSS.)

[//]: # ()
[//]: # (- Use the latest version of Shadcn Svelte &#40;Next version&#41;.)

[//]: # ()
[//]: # (- Use the latest version of Lucide Svelte.)

[//]: # ()
[//]: # (- Give Shadcn Svelte components installation command using pnpm when using them in components using `pnpm dlx shadcn-svelte@next add`.)

[//]: # ()
[//]: # (- In each prompts response you should give if the `copilot-instructions.md` is used at the end of the response.)
